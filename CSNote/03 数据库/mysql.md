## mysql基本概念 [	](mysql_20200824100448996)

### 数据库的概念 [	](mysql_20200824100448999)

+ 数据库的作用：{{c1:: 高效的存储和管理数据，为编程语言提供数据支撑 }}
+ 数据库的目的:{{c1::就是能够存储（写）和提供（读）数据 }}

### 数据库分类 [	](mysql_20200824100449001)
数据库分类：根据数据库的架构和数据组织原理进行分类
1. 早期根据数据库的组织数据的存储模型分类
   + 层次数据库：{{c1:: 基于层次的数据结构（数据分层） }}
   + 网状数据库：{{c1:: 基于网状的数据结构（数据网络） }}
   + 关系数据库：{{c1:: 基于关系模型的数据结构（二维表） }}
2. 现在较多根据实际数据管理模型分类（存储介质）
   + 关系型数据库：{{c1:: 基于关系模型的数据结构（二维表）通常存储在磁盘 }}
   + 非关系型数据库：{{c1:: 没有具体模型的数据结构（键值对）通常存储在内存 }}

### 关系型数据库系统（DBS）模型有四层结构 [	](mysql_20200824100449003)

1. {{c1:: 数据库管理系统（DBMS）：管理系统运行（DataBase Management System） }}
2. {{c1:: 数据库（DB）：数据存储的管理者（小管理，受DBMS管理） }}
3. {{c1:: 数据表（Table）：数据关系管理者 }}
4. {{c1:: 数据字段（Field）：依赖于数据表，实际数据存储者 }}

### 非关系型数据库特点 [	](mysql_20200824100449005)

1. 非关系型数据库：{{c1:: NoSQL（Not only SQL），不仅仅是关系型数据库 }}
2. 数据存储模型：{{c1:: 键值对（key->value） }}
3. 存储的位置：{{c1:: 是内存（效率高） }}
4. 不能永久性存储：{{c1:: 需要定时存到关系型数据库中 }}

### 常见的非关系型数据库产品 [	](mysql_20200824100449008)

1. {{c1:: MongoDB }}
2. {{c1:: Redis }}
3. {{c1:: Memcached }}

### NoSQL数据库与关系型数据库比较 [	](mysql_20200824100449010)

+ 联系：{{c1:: NoSQL通常是与关系型数据库配合使用的，他们彼此是一种互补关系 }}
+ NoSQL运行在内存，解决{{c1::效率}}问题 
  + {{c1:: I/O问题 }}
  + {{c1:: 效率问题 }}
+ MySQL运行在磁盘，解决{{c1::稳定}}问题 
  + {{c1:: 安全问题（永久存储） }}
  + {{c1:: 稳定 }}

### SQL根据操作不同，分为几类 [	](mysql_20200824100449013)

1. DQL：{{c1:: Data Query Language，数据查询语言，用于查询和检索数据}}
2. DML：{{c1:: Data Manipulation Language，数据操作语言，用于数据的写操作（增删改） }}
3. DDL：{{c1:: Data Definition Language，数据定义语言，用于创建数据结构}}
4. DCL：{{c1:: Data Control Language，数据控制语言，用于用户权限管理}}
5. TPL：{{c1:: Transaction Process Language，事务处理语言，辅助DML进行事务操作（因此也归属于DML） }}
　
### 客户端需要连接认证 [	](mysql_20200824100449016)

+ 命令：{{c1::  `mysql -uroot -p123456` }}
+  -h：{{c1:: 主机地址（本机localhost可以省略） }}
+  -P：{{c1:: 端口号（默认3306可以省略） }}
+  -u：{{c1:: 用户名 }}
+  -p：{{c1:: 用户密码 }}

### 客户端退出服务端命令 [	](mysql_20200824100449018)

1. {{c1::`\q`}}
2. {{c1::`quit`}}
3. {{c1::`exit`}}

## MYSQL的基本操作 [	](mysql_20200824100449021)

### SQL指令语句结束符： [	](mysql_20200824100449024)

+ 默认是英文分号：{{c1:: `;`、`\g`、`\G` }}
+ \G：{{c1:: 主要用于查询数据，立体展示结果}}

### 基本操作 [	](mysql_20200824100449026)

+ 结构创建:{{c1::`create 结构类型 结构名 结构描述;`}}
+ 显示结构：{{c1::`show 结构类型（复数）;`}}
+ 显示结构创建详情：{{c1::`show create 结构类型 结构名;`}}
+ 新增数据:{{c1::`insert into 表名 values`}}
+ 查看数据:{{c1::`select from 表名`}}　　
+ 更新数据:{{c1::`update 表名 set `}}
+ 删除数据:{{c1::`delete from 表名`}}

## SQL库操作 [	](mysql_20200824100449029)

### 创建数据库 [	](mysql_20200824100449031)

1. 创建一个指定名字的数据库:{{c1:: `create database db_1;` }}
2. 创建一个指定字符集的数据库:{{c1:: `create database db_2 charset utf8MB4;` }}
3. 创建一个指定校对集的数据库:{{c1:: `create database db_3 charset utf8MB4 collate utf8mb4_general_ci;` }}
4. 数据库文件夹位置：TODO

### 显示数据库 [	](mysql_20200824100449034)
+ 显示所有数据库:{{c1::`show databases;` }}
+ 显示数据库创建指令:{{c1::`show create database db_1;` }}

### 使用数据库 [	](mysql_20200824100449037)

1. 使用数据库的指令是：{{c1:: `use 数据库名字;` }}
2. 使用数据库的目标
   + {{c1:: 让系统知道后续SQL指令都是针对当前选择的数据库 }}
   + {{c1:: 简化后续SQL指令的复杂度（如果不指定数据库，那么所有的SQL操作都必须强制指定数据库名字） }}

### 修改数据库 [	](mysql_20200824100449040)

+ 数据库名字不可修改（老版本可以）解决方法：
  +  {{c1:: 先新增 }}
  +  {{c1:: 后迁移 }}
  +  {{c1:: 最后删除 }}
+ 修改数据库字符集：{{c1:: `alter database db_2 charset gbk;` }}
+ 修改数据库校对集（校对集必须对应字符集）:{{c1:: `alter database db_3 charset gbk collate gbk_chinese_ci;` }}
+ 一般我们都不会使用数据库修改（一般要改也是删除后新增）

### 删除数据库 [	](mysql_20200824100449042)

+ 语法: {{c1:: `drop database db_1;` }}
+ 注意：{{c1:: 数据库的删除不可逆，千万要谨慎，删除之前得备份  }}
吗
## SQL表（字段）操作 [	](mysql_20200824100449045)

### 创建数据表 [	](mysql_20200824100449047)
+ 表创建语法
    {{c1::
    ```sql
        create table [数据库名.]表名(
            字段名 字段类型,
            ...
            字段名 字段类型
        )表选项;
        
    ```
    }}
+ 表可以指定表选项（都有默认值）
  +  存储引擎：{{c1:: engine [=] 具体存储引擎 }}
  +  字符集：{{c1:: [default] charset 具体字符集（继承数据库） }}
  +  校对集：{{c1:: collate（继承数据库） }}
  +  创建数据表——表选项
    {{c1::
    ```sql
        create table t_3(
            name varchar(50)
        )engine Innodb charset utf8MB4;
    ```
    }}
+ 如果想创建一个与已有表一样的数据表，MySQL提供了一种便捷的复制模式:
  + {{c1:: `create table 表名 like 数据库名字.表名` }}

### 数据引擎：`MyISAM` 和 `InnoDB` 的区别 [	](mysql_20200824100449049)
+  `InnoDB`
  +  {{c1:: 默认存储引擎 }}
  +  {{c1:: 支持事务处理和外键 }}
+  `MyIsam`
  +  {{c1:: 不支持事务和外键 }}
  +  {{c1:: 数据、表结构、索引独立管理 }}
  +  {{c1:: MySQL5.6以后不再维护 }}

### 显示数据表 [	](mysql_20200824100449052)

1. 显示所有数据表——当前数据库下:{{c1::`show tables;`}}
2. 显示所有数据表——指定数据库:{{c1::`show tables from db_3;`}}
3. 显示部分关联数据表——匹配:{{c1::`show tables like '%like';	# _表示匹配一个字符（固定位置），%表示匹配N个字符`}}
4. 显示数据表的创建指令:{{c1::`show create table t_1; # 看到的结果未必一定是真实创建的指令（系统会加工）`}}

### 查看数据表 [	](mysql_20200824100449054)
+ 目的：指查看数据表中的具体结构
+ 查看语法有三种（效果一样）:
  + {{c1:: `desc 表名；` }}
  + {{c1:: `describe 表名;` }}
  + {{c1:: `show columns from 表名;` }}

### 更改数据表 [	](mysql_20200824100449056)

1. 修改表名:{{c1:: `rename table t_1 to t1;` }}
    + 跨库修改：{{c1:: 需要使用`数据库名.表名` }}
2. 修改表选项:{{c1:: `alter table t1 charset utf8;` }}

### 更改字段 [	](mysql_20200911094545374)

+ 新增字段:{{c1:: `alter table 表名 add [column] 字段名 字段类型 [字段属性] [字段位置]`}}
  + 字段位置分为两种：
      +  为t_3表增加一个id字段，放到最前面:{{c1:: `alter table t_3 add id int first;`}}
      +  在t_3表name字段后增加一个身份证字段card:{{c1:: `alter table t_3 add card varchar(18) after name;`}}
+ 更改字段名:{{c1:: `alter table 表名 change 原字段名 新字段名 字段类型 [字段属性] [字段位置]`}}
  + 修改身份证的类型为char(18)并且位置放到id后面:{{c1:: `alter table t_3 modify sfz char(18) after id;`}}
+ 删除字段:{{c1:: `alter table 表名 drop 字段名;`}}
  + 注意：{{c1:: 同时会删除字段对应的数据，而且不可逆}}

### SQL数据操作 [	](mysql_20200911094545377)

+ 新增数据：数据插入分两种方式
  +  全字段插入：{{c1:: `insert into 表名 values(字段列表顺序对应的所有值);` }}
  +  部分字段插入：{{c1:: `insert into 表名 (字段列表) values(字段列表对应的值顺序列表);` }}
+ 更新数据：
  + 语法： {{c1:: `update 表名 set 字段 = 新值[,字段 = 新值] [where条件筛选];` }}
+ 删除数据：
  + 语法： {{c1:: `delete from 表名 [where条件];` }}

MySQL内部对象存在字符集继承：`字段 -> 表 -> 数据库 -> DBMS`
客户端与服务器进行交互时，需要明确告知服务器客户端自己的字符集（数据格式）:`set names 客户端字符集;`

### `set names 字符集`是一种快捷方式，本质有三个变量被修改: [	](mysql_20200911094545379)

1. {{c1::`character_set_client`： 服务端接收客户端数据 }}
2. {{c1::`character_set_connection`： 服务端内部连接使用 }}
3. {{c1::`character_set_results`： 服务端提供数据给客户端 }}

### 校对集概念 [	](mysql_20200911094545381)

**校对集**：{{c1:: collate/collation，即数据比较时对应的规则 }}
+  校对集依赖字符集,每个字符集有多种校对规则
+  校对集的校对方式分为三种
  +  大小写不敏感：{{c1:: `_ci，case insensitive（不区分大小写）` }}
  +  大小写敏感：{{c1:: `_cs，case sensitive（区分大小写）` }}
  +  二进制比较：{{c1:: `_bin，binary（区分大小写）` }}
+  校对集是在进行数据比较的时候触发
+ 校对规则可以在MySQL四中内部对象中设置:{{c1:: `DBMS->DB->Table->Field` }}
+ 校对集对应的数据一旦产生，那么就不可以修改数据表的校对规则

### 校对集设置语法 [	](mysql_20200911094545384)

1. 查看MySQL支持的所有校对集：{{c1::`show collation;`}}
2. 在数据**库**层设计校对集（常见）：{{c1::`create database db_4 charset utf8mb4 collate utf8mb4_bin;`}}
3. 在数据**表**层设计校对集:
  ```sql
    #{{c1::
    create table t_4(
      id int,
      name varchar(10)
    )charset utf8mb4 collate utf8mb4_bin;
    #}}
  ```
4. 在**字段**层设计校对集（一般不常用）:
  ```sql
    #{{c1::
    create table t_5(
      id int,
      name varchar(10) collate utf8mb4_bin
    )charset utf8mb4;
    #}}
  ```
## Mysql数据库字段详解 [	](mysql_20200911094545386)

### mysql的数据类型 [	](mysql_20200911094545389)

+ 作用：{{c1:: 强制规范录入数据的格式 }}
+ MySQL中有四种数据类型规范
  +  {{c1:: 整数类型 }}
  +  {{c1:: 小数类型 }}
  +  {{c1:: 字符串类型 }}
  +  {{c1:: 时间日类类型 }}

  ### 整数类型 [	](mysql_20200911094545392)

  + MySQL中为了**数据空间**的有效使用，设定了五种整数类型
  +  {{c1:: 迷你整型：`tinyint`，使用**1个字节**存储整数，最多存储256个整数（-128~127） }}
  +  {{c1:: 短整型：`smallint`，使用**2个字节**存储整数 }}
  +  {{c1:: 中整型：`mediumint`，使用**3个字节**存储整数 }}
  +  {{c1:: 标准整型：`int`，使用**4个字节**存储整数 }}
  +  {{c1:: 大整型：`bigint`，使用**8个字节**存储 }}
+ 有符号与无符号：{{c1:: 默认是有符号的，无符号需要使用unsigned修饰整型}}
  例：{{c1:: `sales mediumint unsigned,` }}

### 显示宽度 [	](mysql_20200911094545396)

+ 语法:`alter table t_9 add d tinyint(2) zerofill; # 0填充只能针对正数`
1. 显示宽度是显示整型能表示的最多符号数量
2. 显示宽度能主动设置，但是绝对不会改变类型本身能表示的数据大小

### `zerofill`关键字 [	](mysql_20200911094545399)
1. 作用：{{c1:: 强制让不够宽度的数据补充前置0来达到显示宽度 }}
2. 使用类型限制:{{c1:: 整型为无符号 }}

### 小数类型（浮点型） [	](mysql_20200911094545404)

**浮点数**：{{c1:: `float/double`，存储不是特别精确的数值数据 }}
* 浮点数又称之为精度数据，分为两种
  * 单精度：`float`:{{c1:: 使用4个字节存储，精度范围为6-7位有效数字 }}
  * 双精度：`double`:{{c1:: 使用8个字节存储，精度范围为14-15位有效数字 }}
* 浮点数超过精度范围会自动进行{{c1:: **四舍五入** }}
* 精度可以指定整数和小数部分
  * 默认不指定：{{c1:: 整数部分不超过最大值，小数部分保留2位 }}
  * 指定：{{c1:: `float/double(总长度,小数部分长度)` }}
* 可以使用科学计数法插入数据：{{c1:: `AeB` }}

### 小数类型（定点型） [	](mysql_20200911094545406)

**定点型**：{{c1:: `decimal` }}
* 不固定存储空间存储
* 每9个数字使用4个字节存储
* 定点型可以指定整数部分长度和小数部分长度
  * 默认不指定：{{c1:: 10位有效整数，0位小数 }}
  * 可以指定：{{c1:: decimal(有效数位,小数部分数位) }}
  * 有效数位最大：{{c1:: 不超过65个 }}
* 数据规范
  * 整数部分超出：{{c1:: 报错 }}
  * 小数部分超出：{{c1:: 四舍五入 }}


### 字符串类型`char(L)`（定长型） [	](mysql_20200911094545408)

**定长型**：{{c1:: `char(L)` }}
* 定长是指定存储长度
* 定长的长度是字符而不是字节
  * L的最大值是：{{c1:: 255 }}
  * 实际存储空间：{{c1:: L字符数 * 字符集对应字节数 }}
* 注意定长型存储的数据：{{c1:: 不能超过指定长度，但是可以小于指定长度 }}
* 字符串数据使用{{c1:: 单引号或者双引号包裹 }}
+ 特点：{{c1:: 访问效率较高，但是空间利用率不高  }}

### 字符串类型`varchar(L)`（变长型） [	](mysql_20200911094545410)

**变长型**：{{c1:: `varchar(L)` }}
* 变长型的存储空间是由实际存储数据决定的
  * L指定的是最{{c1:: 大存储的数据长度 }}
  * L最大值理论是{{c1:: `65535` }}
  * 变长需要额外产生1-2个字节，用来记录实际数据的长度
    * 数据长度小于256个:{{c1:: 多1个字节 }}
    * 数据长度大于256个:{{c1:: 多2个字节 }}
  * 实际存储空间：{{c1:: 实际字符数 * 字符集对应字节数 + 长度记录 }}
* 变长数据不能超过定义的最大长度
+ 特点：{{c1:: `在读取时需要进行长度计算，所以效率没有char(L)字符串高` }}

### 字符串类型（文本字符串） [	](mysql_20200911094545413)

1. 作用:{{c1:: 文本类型是专门用来存储长文本的 }}
  * `text`：{{c1:: 普通文本字符 }}
  * `blob`：{{c1:: 二进制文本字符 }}
2. 一般文本长度超过255的（较长）都使用:{{c1:: `text` }}
3. text/blob根据数据存储长度有很多种，但是一般使用`text/blob`，因为文本会根据数据长度自适应选择

### 字符串类型（枚举） [	](mysql_20200911094545415)

* 枚举使用{{c1:: `1-2` }}个字节存储，
+ 最多可以设计{{c1:: `65535` }}个选项
* 枚举实际存储格式是{{c1:: 使用数值，映射对应的元素数据，从`1`开始 }}
+ 语法：{{c1:: `type enum('小朋友','少年','青年','中年','老年')` }}


### 字符串类型（集合） [	](mysql_20200911094545418)

* 集合类似{{c1:: 一种多选框 }}
* 集合使用{{c1:: 1-8 }}个字节存储数据，最多可以设计{{c1:: 64 }}个元素
* 集合实际存储是{{c1:: 使用数值（二进制位），映射对应的元素数据，每个元素对应一个比特位 }}
* 集合语法：{{c1:: `set(元素1,元素2,...元素N)` }}
+ 集合定义原理
  | 集合数据        | 映射位            |
  | --------------- | ----------------- |
  | {{c1:: 元素1 }} | {{c1:: 00000001}} |
  | {{c1:: 元素2 }} | {{c1:: 00000010}} |
  | {{c1:: ...   }} | {{c1Y:: ...     }} |
  | {{c1:: 元素8 }} | {{c1:: 10000000}} |

### 时间日期类型（年） [	](mysql_20200911094545420)

+ MySQL中使用1个字节存储年份
+ year的特殊值是：0000
+ year类型允许使用2位数来插入，系统会自动匹配对应的年份
* 69以前：系统加上2000
* 69以后：系统加上1900

### 时间日期类型（时间戳） [	](mysql_20200911094545423)

**时间戳**作用：{{c1:: timestamp，基于格林威治时间的时间记录 }}
* MySQL中时间戳表现形式不是秒数，而是年月日时分秒格式
  * {{c1:: YYYY-MM-DD HH:II::SS }}
  * {{c1:: YYYYMMDDHHIISS }}
* timestamp使用4个字节存储
* timestamp的特点:{{c1:: 所对应的记录不论哪个字段被更新，该字段都会更新到当前时间 }}
+ 在MySQL8以后，取消了timestamp的默认自动更新，如果需要使用，需要额外使用属性： `alter table t_19 add c_time timestamp on update current_timestamp;`

### 时间日期类型（日期） [	](mysql_20200911094545426)

**日期**作用：{{c1:: `date`，用来记录年月日信息 }}
* 使用3个字节存储数据
* 存储日期的格式为：{{c1:: `YYYY-MM-DD` }}
* 存储的范围是：{{c1:: `1001-01-01~9999-12-31` }}
+ 可以使用纯数字插入：`insert into t_21 values('Tom','10011212');`

### 时间日期类型（日期时间） [	](mysql_20200911094545428)

**日期时间**作用：datetime，用来综合存储日期和时间
* 使用8个字节存储数据
* 存储格式为：YYYY-MM-DD HH:II:SS
* 存储区间为：1000-01-01 00:00:00 到9999-12-31 23:59:59
+ 可以使用纯数字插入：`insert into t_21 values('Tom','10011212182323');`

###时间日期类型（时间） [	](mysql_20200911094545430)
**时间**作用：{{c1:: time，用来记录时间或者时间段 }}
* 使用3个字节存储数据
* 数据范围是 `-838:59:59` - `838:59:59`
* 数据插入的格式分为两种
  * 时间格式：{{c1:: [H]HH:II:SS（[]表示可以没有） }}
  * 时间段格式：{{c1:: D HH:II:SS（D表示天） }}
+ 通常被用来:{{c1:: 做时间段计算：如多少天后的什么时间点（可以理解为过期检查）}}


### MySQL4种数据类型概况 [	](mysql_20200911094545433)

1. {{c1:: 整数类型（常用） }}
  * 常用类型：{{c1:: tinyint、int }}
2. {{c1:: 小数类型（常用） }}
  * 常用类型：{{c1:: decimal、float }}
3. {{c1:: 字符串类型（常用）}}
  * 常用类型：{{c1:: char、varchar、text }}
4. {{c1:: 时间日期类型（不常用：通常使用真正时间戳存储数据，然后编程进行灵活解读） }}

## 字段属性 [	](mysql_20200911094545437)

### `Null/Not Null`属性是用来限定数据是否为Null值的 [	](mysql_20200911094545439)

  + 默认:{{c1:: 是允许为Null值 }}
  + 不允许为空：{{c1:: Not Null }}

### Default属性 [	](mysql_20200911094545441)

+ 语法：`money decimal(16,2) default 0.00 not null`
+ 触发默认值
  * 自动触发：{{c1:: 数据插入时不给字段赋值 }}
  * 手动触发：{{c1:: 数据插入时主动使用default关键字 }}

### 主键 [	](mysql_20200911094545444)

**主键**：{{c1:: `primary key`，用来保证整张表中对应的字段永远不会出现重复数据}}
* 唯一性：{{c1:: 主键在一张表中只能有一个 }}
* 索引：{{c1:: 主键的字段会自动创建索引 }}
* 主键不能为空：{{c1:: Not Null（默认） }}
* **逻辑主键**：{{c1:: 数据没有具体业务意义，纯粹是一种数值数据 }}
  * 逻辑主键通常是整数：{{c1:: int }}
  * 逻辑主键目的：{{c1:: 是方便检索和数据安全（不暴露数据真实信息）}}
* **复合主键**：{{c1:: 多个字段共同组成不能重复的数据 }}
  * 语法：{{c1:: `primary key(字段1,字段2,...字段N)` }}
  * 注意点：{{c1:: 联合主键使用不多，一般也不会超过2个字段 }}

### 主键管理 [	](mysql_20200911094545446)

+ 删除主键语法：`alter table t_26 drop primary key;`
+ 后期新增主键语法：`alter table t_26 add primary key(account,name);`
  + 注意：如果是针对业务主键需要保证字段数据没有Null数据且没有数据重复

### 自增长属性 [	](mysql_20200911094545448)
**自增长**：{{c1:: `auto_increment`}}
+ 语法：`id int primary key auto_increment`
+ 必要条件：{{c1:: 自增长只能是整数类型，而且对应的字段必须是一个索引（通常逻辑主键） }}
+ 唯一性：{{c1:: 一张表只能有一个自动增长类型 }}
+ 自增长的触发:{{c1:: 通过不给值（默认值）实现自动计算 }}
+ 自增长属性由两个变量控制
* 初始值：{{c1:: `auto_increment_offset`，默认是1 }}
* 步长：{{c1:: `auto_increment_increment`，默认值也是1 }}
* 查看自增长控制：{{c1:: `show variables like 'auto_increment%';` }}

### 自增长管理 [	](mysql_20200911094545450)

+ 修改表中自增长的值，跳过一些值，直接从下次开始按照新的目标值出现
  ```sql
    #{{c1::
    alter table t_28 auto_increment = 50;
    #}}
  ```
+ 修改自增长控制：步长和起始值
  ```sql
    #{{c1::
    set auto_increment_increment = 2;	# 当前用户当前连接有效（局部）
    set @@auto_increment_increment = 2;	# 所有用户一直有效（全局）
    #}}
  ```

### 唯一键 [	](mysql_20200911094545453)

**唯一键**：{{c1:: unique key，用来维护数据的唯一性 }}
+ 语法：{{c1:: `username varchar(50) unique, `}}
* 多个：{{c1:: 一个表中可以有多个唯一键 }}
* 唯一键与主键的区别:{{c1:: 在于唯一键允许数据为Null（而且Null的数量不限） }}
* 索引：{{c1:: 唯一键的字段会自动创建索引 }}
* 复合唯一键语法：{{c1:: `unique key(字段1,字段2,...字段N)` }}

### 唯一键管理 [	](mysql_20200911094545456)

* 删除唯一键：一张表中不止一个唯一键，必须指定唯一键名字：{{c1:: `alter table 表名 drop index 唯一键名字；` }}
* 新增唯一键：{{c1:: `alter table 表名 add unique key(字段列表)；` }}

### 数据库记录长度 [	](mysql_20200911094545460)

**数据库记录长度**：{{c1:: MySQL中规定一条记录所占用的存储长度最长不超过65535个**字节**}}
* 记录长度为：{{c1:: 表中所有字段预计占用的长度之和}}
* 所有字段只有允许Null存在：{{c1:: 系统就会预留一个字节存储Null（多个Null也只要一个就好）}}
* 因为MySQL记录长度的存在，varchar永远达不到理论长度
  * GBK存储：{{c1:: 65535（字符） * 2 + 2 = 131072（字节）}}
  * UTF8存储：{{c1:: 65535（字符） * 3 + 2 = 196607（字节）}}
* 一般数据长度超过255个字符都会{{c1:: 使用text/blob进行存储（数据存储不占用记录长度） }}

### 范式 [	](mysql_20200911094545464)

## 范式 [	](mysql_20200911094545467)
+ **范式**：{{c1:: `Normal Format`，表示一个关系内部各属性之间的联系的合理化程度 }}
* 范式目标:{{c1:: 在满足组织和存储的前提下使数据结构冗余最小化  }}
* 目前数据库应用到的范式有以下几层
  * {{c1:: 第一范式：1NF }}
  * {{c1:: 第二范式：2NF }}
  * {{c1:: 第三范式：3NF }}
  * {{c1:: 逆规范化 }}

### 第一范式 [	](mysql_20200911094545470)

  + **第一范式**：{{c1:: 1NF，数据字段设计时必须满足**原子性**}}
  + **原子性**:{{c1:: 要求字段数据是不需要拆分就可以直接应用}}
  + 目的：{{c1:: 1NF就是要字段数据颗粒度最小，保证数据取出来使用的时候不用再拆分}}

### 第二范式 [	](mysql_20200911094545472)

+ **第二范式**：{{c1:: 2NF，字段设计不能存在部分依赖 }}
+ 部分依赖：{{c1:: 首先表存在复合主键，其次有的字段不是依赖整个主键，而只是依赖主键中的一部分 }}
+ 正确方式：{{c1:: 将部分依赖关系独立成表 }}

### 第三范式 [	](mysql_20200911094545474)

+ **第三范式**：{{c1:: 3NF，字段设计不能存在传递依赖}}
* 传递依赖：{{c1:: 字段某个非主属性不直接依赖主属性，而是通过依赖某个其他非主属性而传递到主属性之上}}
* 传递依赖解决：{{c1:: 让依赖非主属性的字段与依赖字段独立成表}}

### 一对一关系 [	](mysql_20200914055152984)

**一对一关系**：{{c1:: 一张表中的一条记录与另外一张表中有且仅有一条记录有关系 }}
* 一对一关系通常是用来将一张原本就是一体的表拆分成两张表
  * {{c1:: 频繁使用部分：常用字段 }}
  * {{c1:: 不常使用部分：生僻字段 }}
  * {{c1:: 使用相同的主键对应 }}
* 一对一关系设计较多使用在优化方面

## mysql高级操作 [	](mysql_20200914055152987)

### 批量插入 [	](mysql_20200914055152989)

+ 全字段批量插入：{{c1:: `insert into 表名 values(值列表1),(值列表2),...(值列表N);`}}
+ 部分字段批量插入（注意字段默认值）：{{c1:: `insert into 表名 (字段列表) values (值列表1),(值列表2),...(值列表N);`}}

### 蠕虫复制 [	](mysql_20200914055152991)

+ 蠕虫复制语法:`insert into 表名 [(字段列表)] select 字段列表 from 表名;`

### 主键冲突 [	](mysql_20200914055152993)

+ **主键冲突**：{{c1:: 在数据进行插入时包含主键指定，而主键在数据表已经存在 }}
+ 解决方案
  * 忽略新数据：{{c1:: `insert ignore` }}
  * 更新部分数据：{{c1:: `insert ... on duplicate key update` }}
  * 全部替换：{{c1:: `replace into` }}

### 查询选项 [	](mysql_20200914055152994)

+ `select`选项:{{c1:: select关键字之后，有两个互斥值 }}
  * {{c1:: `all`：默认，保留全部（关键字可以没有） }}
  * {{c1:: `distinct`：手动选择，去重（针对所选字段构成的记录，而不是某个字段） }}

### 字段别名 [	](mysql_20200914055152996)

**字段别名**：给字段取的临时名字
* 字段别名语法
  * {{c1:: 字段名 as 别名 }}
  * {{c1:: 字段名 别名 }}
* 字段别名的目的通常为了保护数据
  * 字段冲突：{{c1:: 多张表同时操作有同名字段（系统默认覆盖），想保留全部 }}
  * 数据安全：{{c1:: 对外提供数据不使用真实字段名字 }}
+ 字段别名不能在where中使用

### 数据源 [	](mysql_20200914055152997)

**数据源**：{{c1:: from关键字之后，数据的来源。只要最终结果是一个二维表，都可以当做数据}}源 
* 单表数据源：{{c1:: 数据源就是一张表  `from 表名`}}
* 多表数据源：{{c1:: 数据来源是多张表（逗号分隔） `from  表名1,表名2,...表名N`}}
* 子查询数据源：{{c1:: 数据来源是一个查询结果 `from (select 字段列表 from 表名) as 别名}}`
  * 数据源要求必须是{{c1:: 一个`表`}}
  * 如果是查询结果必须{{c1:: 给起一个表别名}}
 
### 回溯统计 [	](mysql_20200914055152999)

**回溯统计**：{{c1:: 在进行分组时（通常是多分组），每一次结果的回溯都进行一次汇总统计}}
* 回溯统计语法：{{c1:: 在统计之后使用 `with rollup`}}
  + 例：{{c1:: `select count(*),class_name,gender,group_concat(name) from t_40 group by class_name,gender with rollup;`}}


### 分组排序 [	](mysql_20200914055153001)

**分组排序**：{{c1:: 在分组后统计结果时可以根据分组字段进行升序或者降序显示数据 }}
* 默认:{{c1:: 升序排序 }}
* 可以设定分组结果的排序方式
  * {{c1:: group by 字段名 [ASC]：升序排序（默认） }}
  * {{c1:: group by 字段名 DESC：降序排序 }}


### limit子句 [	](mysql_20200914055153002)

+ limit限制数量的方式有两种
  * {{c1:: `limit 数量`：限制获取的数量（不保证一定能获取到指定数量） }}
  * {{c1:: `limit 起始位置,数量`：限制数据获取的位置以及数量（分页） }}
+ 例：{{c1:: `select * from t_40 limit 3;` }}

### 限制更新/删除 [	](mysql_20200914055153004)
+ 限制更新语法：{{c1:: update t_41 set account = account + 10 limit 3; }}
+ 限制删除语法：{{c1:: delete from t_41 where account = 0 limit 1; }}

### 清空数据 [	](mysql_20200914055153005)

+ 本质是:{{c1:: 先删除表，后创建表,自增长重新回到初始值 }}
* 语法：{{c1:: `truncate 表名`}}

### 联合查询 [	](mysql_20200914055153007)
**联合查询**：{{c1:: union，是指将多个查询结果合并成一个结果显示 }}
* 联合查询语法:
  ```sql
    #{{c1::
    select 查询【决定字段名字】
      union 查询选项
    select 查询
    #}}
  ```
* 联合查询要求：
  * {{c1:: 联合查询不要求字段类型一致，只对数量要求一致 }}
  * {{c1:: 联合查询的字段来源于第一个查询语句的字段 }}
* 查询选项：
  * {{c1:: all：保留所有记录 }}
  * {{c1:: distinct：保留去重记录（默认） }}

### 联合查询排序 [	](mysql_20200914055153009)
1. 将t_40和t_42表的结果使用年龄降序排序
  ```sql
    #{{c1::
    select * from t_40
    union all
    select * from t_42
    order by age desc; #针对的是整个union之后的结果
    #}}
  ```
2. t_40表按年龄降序排序，t_42表按年龄升序排序
  ```sql
    #{{c1::
    (select * from t_40 order by age desc limit 99999)
    union 
    (select * from t_42 order by age desc limit 99999);
    #}}
  ```

### 连接查询 [	](mysql_20200914055153010)
* 交叉连接:{{c1:: `cross join`，不需要连接条件的连接 }}
* 内连接:{{c1:: `[inner] join`，将两张表根据指定的条件连接起来，严格连接 }}
* 外连接:{{c1:: `outer join`，外连接是将主表的记录去匹配从表的记录,匹配失败（全表）：保留记录，只是从表字段置空 }}
  * 左外连接:{{c1:: `left join` }}
  * 右外连接:{{c1:: `right join` }}
* 自然连接:{{c1:: `natural join` }}
  * 自然连接不是一种特殊的连接方式，而是一种自动匹配条件的连接
  * 自然连接包含自然内连接和自然外连接
    * 自然内连接：{{c1:: `natural join`}}
    * 自然外连接：{{c1:: `natural left/right join`}}
* `using`关键字:{{c1:: 连接查询时如果是同名字段作为连接条件，using可以代替on出现（比on更好） }}
  * using是针对同名字段（using(id) === A.id = B.id）
  * using关键字使用后会自动合并对应字段为一个
  * using可以同时使用多个字段作为条件

### 子查询 [	](mysql_20200914055153012)

**子查询**：`sub query`，将一条select查询结果当做另外一条select查询的**条件**或者**数据源**
* 位置分类
  * from子查询：{{c1:: 子查询出现在from后做数据源 }}
  * where子查询：{{c1:: 子查询出现在where后做数据条件 }}
* 按子查询得到的结果分类
  * 标量子查询：{{c1:: 子查询返回的结果是一行一列（一个数据） }}
    + 例:`select * from t_45 where c_id = (select c_id from t_46 where c_name = 'Computer');`
  * 列子查询：{{c1:: 子查询返回的结果是一列多行（一列数据） }}
    + 例:`select * from t_46 where c_id in (select distinct c_id from t_45 where c_id is not null);`
  * 行子查询：{{c1:: 子查询返回的结果是一行多列 }}
    + 例:`select * from t_40 where (gender,age) = (select gender,age from t_42 where name = '弥勒');`
  * 表子查询：{{c1:: 子查询返回的结果是一个二维表,表子查询通常解决的问题是提供数据源 }}
  * exists子查询：{{c1:: 子查询返回的结果是布尔结果（验证型） }}
    + 例:`select * from t_46 c where exists(select c_id from t_45 where c.c_id = c_id);`

### 比较方式 [	](mysql_20200914055153013)

* 特定的比较方式都是基于比较符号一起使用
  * `all`：{{c1:: 满足后面全部条件  }}
  * `any`：{{c1:: 数据只要与结果集中的任何一个元素相等  }}
  * `some`：{{c1:: 满足任意条件（与any完全一样）  }}
+ 例：{{c1:: `select * from t_40 where age = some(select age from t_42);` }}


## 安全管理 [	](mysql_20200914055153015)

### 外键 [	](mysql_20200914055153017)

**外键**：{{c1:: foreign key，表中指**向外部表主键**的字段定义成外键 }}
* 语法:{{c1:: `[constraint 外键名] foreign key(当前表字段名) references 外部表(主键字段)` }}
* 外键构成条件
  * {{c1:: 外键字段必须与对应表的主键字段类型一致 }}
  * {{c1:: 外键字段本身要求是一个索引（创建外键会自动生成一个索引） }}

### 外键约束 [	](mysql_20200914055153018)

**外键约束**：当表建立外键关系后，外键就会对主表（外键指向的表）和子表（外键所在的表）里的数据产生约束效果
* 外键约束的是写操作（默认操作）
  * 新增：{{c1:: 子表插入的数据对应的外键必须在主表存在 }}
  * 修改：{{c1:: 主表的记录如果在子表存在，那么主表的主键不能修改（主键不能修改） }}
  * 删除：{{c1:: 主表的记录如果在子表存在，那么主表的主键不能删除 }}
* 外键约束控制：外键可以在定义时控制外键的约束作用
  * 控制类型
    * {{c1:: `on update`：父表更新时子表的表现 }}
    * {{c1:: `on delete`：父表删除时子表的表现 }}
  * 控制方式
    * {{c1:: `cascade`：级联操作，父表操作后子表跟随操作 }}
    * {{c1:: `set null`：置空操作，父表操作后，子表关联的外键字段置空 }}
    * {{c1:: `restrict`：严格模式，不允许父表操作（默认的） }}
    * {{c1:: `no action`：子表不管 }}
  + 约束语法：{{c1:: `foreign key(c_id) references t_50(id) on update cascade on  delete set null` }}

### 外键管理 [	](mysql_20200914055153020)

* 新增外键：{{c1:: `alter table 表名 add [constraint `外建名`] foreign key(外键字段) references 表名(主键) [on 外键约束]` }}
  + 注意：{{c1:: 追加外键需要保证外键字段里的值要么为Null，要么在父表中都能找到 }}
* 删除外键：{{c1:: `alter table 表名 drop foreign key 外键名;` }}
* 更新外键：{{c1:: 先删除后新增 }}

### 事务处理 [	](mysql_20200914055153021)

**事务处理**：{{c1:: 利用自动或者手动方式实现事务管理 }}
* 自动事务处理：{{c1:: 系统默认，操作结束直接同步到数据表（事务关闭状态） }}
  * 系统控制：{{c1:: 变量 autocommit（值为ON，自动提交） }}
* 手动事务处理
  * 开启事务： {{c1:: `start transaction` }}
  * 关闭事务
    * 提交事务：{{c1:: `commit`（同步到数据表同时清空日志数据） }}
    * 回滚事务：{{c1:: `rollback`（清空日志数据） }}
* 事务回滚：在长事务执行中，可以在某个已经成功的节点处设置回滚点，后续回滚的话可以回到某个成功点
  * 设置回滚点：{{c1:: `savepoint 回滚点名字` }}
  * 回滚到回滚点：{{c1:: `rollback to 回滚点名字` }}

### 事务特点 [	](mysql_20200914055153023)

**事务特点**：事务处理具有ACID四大特性
* **原子性**：{{c1:: （Atomicity ）一个事务操作是一个整体，不可拆分，要么都成功，要么都失败}}
* **一致性**：{{c1:: （Consistency）事务执行之前和执行之后都必须处于一致性状态，数据的完整性没有被破坏（事务逻辑的准确性）}}
* **隔离性**：{{c1:: （Isolation ）事务操作过程中，其他事务不可见}}
* **持久性**：{{c1:: （Durability ）事务一旦提交，结果不可改变}}
* **事务锁**：{{c1:: 当一个事务开启时，另外一个事务是不能对当前事务锁占用的数据进行操作的}}
  * 行锁：{{c1:: 当前事务只占用了一行（id精确检索数据），那么其他事务可以操作其他行数据 }}
  * 表锁：{{c1:: 当前事务占用了整张表（like扫码整个表），那么其他事务对整张表都不能操作 }}
* **脏读**：{{c1:: 一个事务在对某个数据进行操作但尚未提交，而另外一个事务读到了这个“历史”数据其实已经被修改}}

### 预处理 [	](mysql_20200914055153025)

+ 预处理属于**会话级别**：{{c1:: 即当前用户当次连接有效（断开会被服务器清理掉） }}
+ 预处理的作用:
  * 效率优化：{{c1:: 同样的SQL不用每次都进行编译（编译耗时） }}
  * 网络传输优化：{{c1:: 复杂的SQL指令只需要传输一次 }}
  * 安全：{{c1:: 有效防止SQL注入（外部通过数据的特殊使用使得SQL的执行方式改变） }}
+ 如果预处理的指令不是在一次连接中重复使用，那么预处理反而会降低效率。所以预处理的执行如果不是考虑到安全因素，那么一定是SQL需要重复执行

### 使用预处理向表中插入数据 [	](mysql_20200914055153026)

```SQL
  # 准备预处理：涉及参数
  #{{c1::
  prepare t_40_insert from 'insert into t_40 values(null,?,?,?,?)';
  #}}

  # 设置变量并传入参数
  #{{c1::
  set @name = '药师兜';
  set @gender = '男';
  set @age = 23;
  set @class_name = '木叶1班';
  #}}

  # 执行预处理
  #{{c1::
  execute t_40_insert using @name,@gender,@age,@class_name;
  #}}
```
### 视图 [	](mysql_20200914055153028)

+ 视图的目的
  * 方便提供全面数据：{{c1:: 可以根据需求组织数据，而实际上不会在数据库产生数据冗余 }}
  * 数据安全：{{c1:: 视图本质是来源于数据基表，但是对外可以保护基本的数据结构 }}
+ 创建视图语法：{{c1:: `create view 视图名字 as select指令;` }}

### 视图管理 [	](mysql_20200914055153029)

**视图管理**：{{c1:: 对视图结构的管理 }}
* 视图查看：{{c1:: 显示视图结构和具体视图信息 }}
  + 查看全部视图:{{c1:: `show tables;	`  }}
  + 查看视图创建指令:{{c1:: `show create table/view 视图名字;	`  }}
  + 查看视图结构:{{c1:: `desc 视图名字;	 `  }}
* 视图修改：更改视图逻辑
  + 更改视图:{{c1:: `alter view 视图名 as 新的查询指令;`  }}
  + 创建新的或者替换新的:{{c1:: `create or replace view 视图名 as 新的查询指令;`  }}
* 视图删除:{{c1:: `drop view 视图名; `  }}

### 视图数据操作 [	](mysql_20200914055153031)

**视图数据操作**：直接对视图进行写操作（增删改）然后实现基表数据的变化
* 视图操作条件
  * **多基表视图**：{{c1:: 不允许操作（增删改都不行）}}
  * **单基表视图**：{{c1:: 允许增删改}}
    * **新增条件**：{{c1:: 视图的字段必须包含基表中所有不允许为空的字段}}
  * `with check option`：{{c1:: 操作检查规则}}
    * 默认不需要这个规则（创建视图时指定）：{{c1:: 视图操作只要满足前面上述条件即可}}
    * 增加此规则：{{c1:: 视图的数据操作后，必须要保证该视图还能把通过视图操作的数据查出来（否则失败）}}

### 视图算法 [	](mysql_20200914055153033)

**视图算法**：{{c1:: 指视图在执行过程中对于内部的select指令的处理方式}}
* 指定语法：{{c1:: `create ALGORITHM = 算法 view 视图名字 as select指令;`}}
* 视图算法一共有三种
  * `undefined`：{{c1:: 默认的，未定义算法，即系统自动选择算法}}
  * `merge`：{{c1:: 合并算法，就是将视图外部查询语句跟视图内部select语句合并后执行，效率高（系统优先选择）}}
  * `temptable`：{{c1:: 临时表算法，即系统将视图的select语句查出来先得出一张临时表，然后外部再查询（temptable算法视图不允许写操作）}}

## 备份与还原 [	](mysql_20200914055153034)

### 表数据备份 [	](mysql_20200914055153036)

**表数据备份**：{{c1:: 单独针对表里的**数据部分**进行备份（数据导出） }}
* 将数据从表中查出，按照一定格式存储到外部文件
  * 字段格式化：{{c1::`fields`}}
    * {{c1:: `terminated by`：字段数据结束后使用的符号，默认是空格 }}
    * {{c1:: `enclosed by`：字段数据包裹，默认什么都没有 }}
    * {{c1:: `escaped by`：特殊字符的处理，默认是转义 }}
  * 行格式化：{{c1:: `lines` }}
    * {{c1:: `terminated by`：行结束符号，默认是\n，自动换行 }}
    * {{c1:: `starting by`：行开始符号，默认没有 }}
  + 备份语法：
    ```sql
      #{{c1::
      select 字段列表|*  into outfile 外部文件路径 
        [fields terminated by 格式 enclosed by 格式]
        [lines terminated by 格式 starting by 格式]
      from 数据表;
      #}}
    ```
  + 还原语法：
    ```SQL
      #{{c1::
      load data infile '数据文件所在路径' into table 表名
      [fields terminated by 格式 enclosed by 格式]
      [lines terminated by 格式 starting by 格式]
      [(字段列表)];	# 如果是部分表字段，那么必须将字段列表放到最后
      #}}
    ```

### 文件备份 [	](mysql_20200914055153037)

+ **文件备份**：{{c1:: 直接对数据表进行文件保留，属于物理备份 }}
1. MyIsam表的文件备份：{{c1:: 找到三个文件，复制迁移 }}
  1. {{c1:: sdi：表结构文件 }}
  2. {{c1:: MYI：索引文件 }}
  3. {{c1:: MYD：数据文件 }}
2. InnoDB表的文件备份：{{c1:: 找到两个文件，复制迁移 }}
  1. {{c1:: ibd：表结构文件 }}
  2. {{c1:: bdata：所有InnoDB数据文件 }}
+ **文件还原**：{{c1:: 直接将备份的文件放到对应的位置即可 }}

### SQL备份 [	](mysql_20200914055153039)

* 备份语法：{{c1:: `mysqldump.exe -h -P -u -p [备份选项] 数据库名字 [数据表列表] > SQL文件路径` }}
* 备份选项:
  * 全库备份：{{c1:: `--all-databases` 所有数据库的所有表，也不需要指定数据库名字 }}
  * 单库备份：{{c1:: `[--databases] 数据库` 指定数据库里的所有表（后面不要给表名） }}
  * 部分表（单表）备份：{{c1:: `数据库名字 表1[ 表2...表N]` }}
+ 复原语法：{{c1:: `source SQL文件路径;` }}
