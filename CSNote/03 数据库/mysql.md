## mysql基本概念 [	](mysql_20200824100448996)

### 数据库的概念 [	](mysql_20200824100448999)

+ 数据库的作用：{{c1:: 高效的存储和管理数据，为编程语言提供数据支撑 }}
+ 数据库的目的:{{c1::就是能够存储（写）和提供（读）数据 }}

### 数据库分类 [	](mysql_20200824100449001)
数据库分类：根据数据库的架构和数据组织原理进行分类
1. 早期根据数据库的组织数据的存储模型分类
   + 层次数据库：{{c1:: 基于层次的数据结构（数据分层） }}
   + 网状数据库：{{c1:: 基于网状的数据结构（数据网络） }}
   + 关系数据库：{{c1:: 基于关系模型的数据结构（二维表） }}
2. 现在较多根据实际数据管理模型分类（存储介质）
   + 关系型数据库：{{c1:: 基于关系模型的数据结构（二维表）通常存储在磁盘 }}
   + 非关系型数据库：{{c1:: 没有具体模型的数据结构（键值对）通常存储在内存 }}

### 关系型数据库系统（DBS）模型有四层结构 [	](mysql_20200824100449003)

1. {{c1:: 数据库管理系统（DBMS）：管理系统运行（DataBase Management System） }}
2. {{c1:: 数据库（DB）：数据存储的管理者（小管理，受DBMS管理） }}
3. {{c1:: 数据表（Table）：数据关系管理者 }}
4. {{c1:: 数据字段（Field）：依赖于数据表，实际数据存储者 }}

### 非关系型数据库特点 [	](mysql_20200824100449005)

1. 非关系型数据库：{{c1:: NoSQL（Not only SQL），不仅仅是关系型数据库 }}
2. 数据存储模型：{{c1:: 键值对（key->value） }}
3. 存储的位置：{{c1:: 是内存（效率高） }}
4. 不能永久性存储：{{c1:: 需要定时存到关系型数据库中 }}

### 常见的非关系型数据库产品 [	](mysql_20200824100449008)

1. {{c1:: MongoDB }}
2. {{c1:: Redis }}
3. {{c1:: Memcached }}

### NoSQL数据库与关系型数据库比较 [	](mysql_20200824100449010)

+ 联系：{{c1:: NoSQL通常是与关系型数据库配合使用的，他们彼此是一种互补关系 }}
+ NoSQL运行在内存，解决{{c1::效率}}问题 
  + {{c1:: I/O问题 }}
  + {{c1:: 效率问题 }}
+ MySQL运行在磁盘，解决{{c1::稳定}}问题 
  + {{c1:: 安全问题（永久存储） }}
  + {{c1:: 稳定 }}

### SQL根据操作不同，分为几类 [	](mysql_20200824100449013)

1. DQL：{{c1:: Data Query Language，数据查询语言，用于查询和检索数据}}
2. DML：{{c1:: Data Manipulation Language，数据操作语言，用于数据的写操作（增删改） }}
3. DDL：{{c1:: Data Definition Language，数据定义语言，用于创建数据结构}}
4. DCL：{{c1:: Data Control Language，数据控制语言，用于用户权限管理}}
5. TPL：{{c1:: Transaction Process Language，事务处理语言，辅助DML进行事务操作（因此也归属于DML） }}
　
### 客户端需要连接认证 [	](mysql_20200824100449016)

+ 命令：{{c1::  `mysql -uroot -p123456` }}
+  -h：{{c1:: 主机地址（本机localhost可以省略） }}
+  -P：{{c1:: 端口号（默认3306可以省略） }}
+  -u：{{c1:: 用户名 }}
+  -p：{{c1:: 用户密码 }}

### 客户端退出服务端命令 [	](mysql_20200824100449018)

1. {{c1::`\q`}}
2. {{c1::`quit`}}
3. {{c1::`exit`}}

## MYSQL的基本操作 [	](mysql_20200824100449021)

### SQL指令语句结束符： [	](mysql_20200824100449024)

+ 默认是英文分号：{{c1:: `;`、`\g`、`\G` }}
+ \G：{{c1:: 主要用于查询数据，立体展示结果}}

### 基本操作 [	](mysql_20200824100449026)

+ 结构创建:{{c1::`create 结构类型 结构名 结构描述;`}}
+ 显示结构：{{c1::`show 结构类型（复数）;`}}
+ 显示结构创建详情：{{c1::`show create 结构类型 结构名;`}}
+ 新增数据:{{c1::`insert into 表名 values`}}
+ 查看数据:{{c1::`select from 表名`}}　　
+ 更新数据:{{c1::`update 表名 set `}}
+ 删除数据:{{c1::`delete from 表名`}}

## SQL库操作 [	](mysql_20200824100449029)

### 创建数据库 [	](mysql_20200824100449031)

1. 创建一个指定名字的数据库:{{c1:: `create database db_1;` }}
2. 创建一个指定字符集的数据库:{{c1:: `create database db_2 charset utf8MB4;` }}
3. 创建一个指定校对集的数据库:{{c1:: `create database db_3 charset utf8MB4 collate utf8mb4_general_ci;` }}
4. 数据库文件夹位置：TODO

### 显示数据库 [	](mysql_20200824100449034)
+ 显示所有数据库:{{c1::`show databases;` }}
+ 显示数据库创建指令:{{c1::`show create database db_1;` }}

### 使用数据库 [	](mysql_20200824100449037)

1. 使用数据库的指令是：{{c1:: `use 数据库名字;` }}
2. 使用数据库的目标
   + {{c1:: 让系统知道后续SQL指令都是针对当前选择的数据库 }}
   + {{c1:: 简化后续SQL指令的复杂度（如果不指定数据库，那么所有的SQL操作都必须强制指定数据库名字） }}

### 修改数据库 [	](mysql_20200824100449040)

+ 数据库名字不可修改（老版本可以）解决方法：
  +  {{c1:: 先新增 }}
  +  {{c1:: 后迁移 }}
  +  {{c1:: 最后删除 }}
+ 修改数据库字符集：{{c1:: `alter database db_2 charset gbk;` }}
+ 修改数据库校对集（校对集必须对应字符集）:{{c1:: `alter database db_3 charset gbk collate gbk_chinese_ci;` }}
+ 一般我们都不会使用数据库修改（一般要改也是删除后新增）

### 删除数据库 [	](mysql_20200824100449042)

+ 语法: {{c1:: `drop database db_1;` }}
+ 注意：{{c1:: 数据库的删除不可逆，千万要谨慎，删除之前得备份  }}
吗
## SQL表（字段）操作 [	](mysql_20200824100449045)

### 创建数据表 [	](mysql_20200824100449047)
+ 表创建语法
    {{c1::
    ```sql
        create table [数据库名.]表名(
            字段名 字段类型,
            ...
            字段名 字段类型
        )表选项;
        
    ```
    }}
+ 表可以指定表选项（都有默认值）
  +  存储引擎：{{c1:: engine [=] 具体存储引擎 }}
  +  字符集：{{c1:: [default] charset 具体字符集（继承数据库） }}
  +  校对集：{{c1:: collate（继承数据库） }}
  +  创建数据表——表选项
    {{c1::
    ```sql
        create table t_3(
            name varchar(50)
        )engine Innodb charset utf8MB4;
    ```
    }}
+ 如果想创建一个与已有表一样的数据表，MySQL提供了一种便捷的复制模式:
  + {{c1:: `create table 表名 like 数据库名字.表名` }}

### 数据引擎：`MyISAM` 和 `InnoDB` 的区别 [	](mysql_20200824100449049)
+  `InnoDB`
  +  {{c1:: 默认存储引擎 }}
  +  {{c1:: 支持事务处理和外键 }}
+  `MyIsam`
  +  {{c1:: 不支持事务和外键 }}
  +  {{c1:: 数据、表结构、索引独立管理 }}
  +  {{c1:: MySQL5.6以后不再维护 }}

### 显示数据表 [	](mysql_20200824100449052)

1. 显示所有数据表——当前数据库下:{{c1::`show tables;`}}
2. 显示所有数据表——指定数据库:{{c1::`show tables from db_3;`}}
3. 显示部分关联数据表——匹配:{{c1::`show tables like '%like';	# _表示匹配一个字符（固定位置），%表示匹配N个字符`}}
4. 显示数据表的创建指令:{{c1::`show create table t_1; # 看到的结果未必一定是真实创建的指令（系统会加工）`}}

### 查看数据表 [	](mysql_20200824100449054)
+ 目的：指查看数据表中的具体结构
+ 查看语法有三种（效果一样）:
  + {{c1:: `desc 表名；` }}
  + {{c1:: `describe 表名;` }}
  + {{c1:: `show columns from 表名;` }}

### 更改数据表 [	](mysql_20200824100449056)

1. 修改表名:{{c1:: `rename table t_1 to t1;` }}
    + 跨库修改：{{c1:: 需要使用`数据库名.表名` }}
2. 修改表选项:{{c1:: `alter table t1 charset utf8;` }}

### 更改字段

+ 新增字段:{{c1:: `alter table 表名 add [column] 字段名 字段类型 [字段属性] [字段位置]`}}
  + 字段位置分为两种：
      +  为t_3表增加一个id字段，放到最前面:{{c1:: `alter table t_3 add id int first;`}}
      +  在t_3表name字段后增加一个身份证字段card:{{c1:: `alter table t_3 add card varchar(18) after name;`}}
+ 更改字段名:{{c1:: `alter table 表名 change 原字段名 新字段名 字段类型 [字段属性] [字段位置]`}}
  + 修改身份证的类型为char(18)并且位置放到id后面:{{c1:: `alter table t_3 modify sfz char(18) after id;`}}
+ 删除字段:{{c1:: `alter table 表名 drop 字段名;`}}
  + 注意：{{c1:: 同时会删除字段对应的数据，而且不可逆}}

### SQL数据操作

+ 新增数据：数据插入分两种方式
  +  全字段插入：{{c1:: `insert into 表名 values(字段列表顺序对应的所有值);` }}
  +  部分字段插入：{{c1:: `insert into 表名 (字段列表) values(字段列表对应的值顺序列表);` }}
+ 更新数据：
  + 语法： {{c1:: `update 表名 set 字段 = 新值[,字段 = 新值] [where条件筛选];` }}
+ 删除数据：
  + 语法： {{c1:: `delete from 表名 [where条件];` }}

MySQL内部对象存在字符集继承：`字段 -> 表 -> 数据库 -> DBMS`
客户端与服务器进行交互时，需要明确告知服务器客户端自己的字符集（数据格式）:`set names 客户端字符集;`

### `set names 字符集`是一种快捷方式，本质有三个变量被修改:

1. {{c1::`character_set_client`： 服务端接收客户端数据 }}
2. {{c1::`character_set_connection`： 服务端内部连接使用 }}
3. {{c1::`character_set_results`： 服务端提供数据给客户端 }}

### 校对集概念

**校对集**：{{c1:: collate/collation，即数据比较时对应的规则 }}
+  校对集依赖字符集,每个字符集有多种校对规则
+  校对集的校对方式分为三种
  +  大小写不敏感：{{c1:: `_ci，case insensitive（不区分大小写）` }}
  +  大小写敏感：{{c1:: `_cs，case sensitive（区分大小写）` }}
  +  二进制比较：{{c1:: `_bin，binary（区分大小写）` }}
+  校对集是在进行数据比较的时候触发
+ 校对规则可以在MySQL四中内部对象中设置:{{c1:: `DBMS->DB->Table->Field` }}
+ 校对集对应的数据一旦产生，那么就不可以修改数据表的校对规则

### 校对集设置语法

1. 查看MySQL支持的所有校对集：{{c1::`show collation;`}}
2. 在数据**库**层设计校对集（常见）：{{c1::`create database db_4 charset utf8mb4 collate utf8mb4_bin;`}}
3. 在数据**表**层设计校对集:
  ```sql
    #{{c1::
    create table t_4(
      id int,
      name varchar(10)
    )charset utf8mb4 collate utf8mb4_bin;
    #}}
  ```
4. 在**字段**层设计校对集（一般不常用）:
  ```sql
    #{{c1::
    create table t_5(
      id int,
      name varchar(10) collate utf8mb4_bin
    )charset utf8mb4;
    #}}
  ```
## Mysql数据库字段详解

### mysql的数据类型

+ 作用：{{c1:: 强制规范录入数据的格式 }}
+ MySQL中有四种数据类型规范
  +  {{c1:: 整数类型 }}
  +  {{c1:: 小数类型 }}
  +  {{c1:: 字符串类型 }}
  +  {{c1:: 时间日类类型 }}

  ### 整数类型

  + MySQL中为了**数据空间**的有效使用，设定了五种整数类型
  +  {{c1:: 迷你整型：`tinyint`，使用**1个字节**存储整数，最多存储256个整数（-128~127） }}
  +  {{c1:: 短整型：`smallint`，使用**2个字节**存储整数 }}
  +  {{c1:: 中整型：`mediumint`，使用**3个字节**存储整数 }}
  +  {{c1:: 标准整型：`int`，使用**4个字节**存储整数 }}
  +  {{c1:: 大整型：`bigint`，使用**8个字节**存储 }}
+ 有符号与无符号：{{c1:: 默认是有符号的，无符号需要使用unsigned修饰整型}}
  例：{{c1:: `sales mediumint unsigned,` }}

### 显示宽度

+ 语法:`alter table t_9 add d tinyint(2) zerofill; # 0填充只能针对正数`
1. 显示宽度是显示整型能表示的最多符号数量
2. 显示宽度能主动设置，但是绝对不会改变类型本身能表示的数据大小

### `zerofill`关键字
1. 作用：{{c1:: 强制让不够宽度的数据补充前置0来达到显示宽度 }}
2. 使用类型限制:{{c1:: 整型为无符号 }}

### 小数类型（浮点型）

**浮点数**：{{c1:: `float/double`，存储不是特别精确的数值数据 }}
* 浮点数又称之为精度数据，分为两种
  * 单精度：`float`:{{c1:: 使用4个字节存储，精度范围为6-7位有效数字 }}
  * 双精度：`double`:{{c1:: 使用8个字节存储，精度范围为14-15位有效数字 }}
* 浮点数超过精度范围会自动进行{{c1:: **四舍五入** }}
* 精度可以指定整数和小数部分
  * 默认不指定：{{c1:: 整数部分不超过最大值，小数部分保留2位 }}
  * 指定：{{c1:: `float/double(总长度,小数部分长度)` }}
* 可以使用科学计数法插入数据：{{c1:: `AeB` }}

### 小数类型（定点型）

**定点型**：{{c1:: `decimal` }}
* 不固定存储空间存储
* 每9个数字使用4个字节存储
* 定点型可以指定整数部分长度和小数部分长度
  * 默认不指定：{{c1:: 10位有效整数，0位小数 }}
  * 可以指定：{{c1:: decimal(有效数位,小数部分数位) }}
  * 有效数位最大：{{c1:: 不超过65个 }}
* 数据规范
  * 整数部分超出：{{c1:: 报错 }}
  * 小数部分超出：{{c1:: 四舍五入 }}


### 字符串类型`char(L)`（定长型）

**定长型**：{{c1:: `char(L)` }}
* 定长是指定存储长度
* 定长的长度是字符而不是字节
  * L的最大值是：{{c1:: 255 }}
  * 实际存储空间：{{c1:: L字符数 * 字符集对应字节数 }}
* 注意定长型存储的数据：{{c1:: 不能超过指定长度，但是可以小于指定长度 }}
* 字符串数据使用{{c1:: 单引号或者双引号包裹 }}
+ 特点：{{c1:: 访问效率较高，但是空间利用率不高  }}

### 字符串类型`varchar(L)`（变长型）

**变长型**：{{c1:: `varchar(L)` }}
* 变长型的存储空间是由实际存储数据决定的
  * L指定的是最{{c1:: 大存储的数据长度 }}
  * L最大值理论是{{c1:: `65535` }}
  * 变长需要额外产生1-2个字节，用来记录实际数据的长度
    * 数据长度小于256个:{{c1:: 多1个字节 }}
    * 数据长度大于256个:{{c1:: 多2个字节 }}
  * 实际存储空间：{{c1:: 实际字符数 * 字符集对应字节数 + 长度记录 }}
* 变长数据不能超过定义的最大长度
+ 特点：{{c1:: `在读取时需要进行长度计算，所以效率没有char(L)字符串高` }}

### 字符串类型（文本字符串）

1. 作用:{{c1:: 文本类型是专门用来存储长文本的 }}
  * `text`：{{c1:: 普通文本字符 }}
  * `blob`：{{c1:: 二进制文本字符 }}
2. 一般文本长度超过255的（较长）都使用:{{c1:: `text` }}
3. text/blob根据数据存储长度有很多种，但是一般使用`text/blob`，因为文本会根据数据长度自适应选择

### 字符串类型（枚举）

* 枚举使用{{c1:: `1-2` }}个字节存储，
+ 最多可以设计{{c1:: `65535` }}个选项
* 枚举实际存储格式是{{c1:: 使用数值，映射对应的元素数据，从`1`开始 }}
+ 语法：{{c1:: `type enum('小朋友','少年','青年','中年','老年')` }}


### 字符串类型（集合）

* 集合类似{{c1:: 一种多选框 }}
* 集合使用{{c1:: 1-8 }}个字节存储数据，最多可以设计{{c1:: 64 }}个元素
* 集合实际存储是{{c1:: 使用数值（二进制位），映射对应的元素数据，每个元素对应一个比特位 }}
* 集合语法：{{c1:: `set(元素1,元素2,...元素N)` }}
+ 集合定义原理
  | 集合数据        | 映射位            |
  | --------------- | ----------------- |
  | {{c1:: 元素1 }} | {{c1:: 00000001}} |
  | {{c1:: 元素2 }} | {{c1:: 00000010}} |
  | {{c1:: ...   }} | {{c1Y:: ...     }} |
  | {{c1:: 元素8 }} | {{c1:: 10000000}} |

### 时间日期类型（年）

+ MySQL中使用1个字节存储年份
+ year的特殊值是：0000
+ year类型允许使用2位数来插入，系统会自动匹配对应的年份
* 69以前：系统加上2000
* 69以后：系统加上1900

### 时间日期类型（时间戳）

**时间戳**作用：{{c1:: timestamp，基于格林威治时间的时间记录 }}
* MySQL中时间戳表现形式不是秒数，而是年月日时分秒格式
  * {{c1:: YYYY-MM-DD HH:II::SS }}
  * {{c1:: YYYYMMDDHHIISS }}
* timestamp使用4个字节存储
* timestamp的特点:{{c1:: 所对应的记录不论哪个字段被更新，该字段都会更新到当前时间 }}
+ 在MySQL8以后，取消了timestamp的默认自动更新，如果需要使用，需要额外使用属性： `alter table t_19 add c_time timestamp on update current_timestamp;`

### 时间日期类型（日期）

**日期**作用：{{c1:: `date`，用来记录年月日信息 }}
* 使用3个字节存储数据
* 存储日期的格式为：{{c1:: `YYYY-MM-DD` }}
* 存储的范围是：{{c1:: `1001-01-01~9999-12-31` }}
+ 可以使用纯数字插入：`insert into t_21 values('Tom','10011212');`

### 时间日期类型（日期时间）

**日期时间**作用：datetime，用来综合存储日期和时间
* 使用8个字节存储数据
* 存储格式为：YYYY-MM-DD HH:II:SS
* 存储区间为：1000-01-01 00:00:00 到9999-12-31 23:59:59
+ 可以使用纯数字插入：`insert into t_21 values('Tom','10011212182323');`

###时间日期类型（时间）
**时间**作用：{{c1:: time，用来记录时间或者时间段 }}
* 使用3个字节存储数据
* 数据范围是 `-838:59:59` - `838:59:59`
* 数据插入的格式分为两种
  * 时间格式：{{c1:: [H]HH:II:SS（[]表示可以没有） }}
  * 时间段格式：{{c1:: D HH:II:SS（D表示天） }}
+ 通常被用来:{{c1:: 做时间段计算：如多少天后的什么时间点（可以理解为过期检查）}}


### MySQL4种数据类型概况

1. {{c1:: 整数类型（常用） }}
  * 常用类型：{{c1:: tinyint、int }}
2. {{c1:: 小数类型（常用） }}
  * 常用类型：{{c1:: decimal、float }}
3. {{c1:: 字符串类型（常用）}}
  * 常用类型：{{c1:: char、varchar、text }}
4. {{c1:: 时间日期类型（不常用：通常使用真正时间戳存储数据，然后编程进行灵活解读） }}

## 字段属性

### `Null/Not Null`属性是用来限定数据是否为Null值的

  + 默认:{{c1:: 是允许为Null值 }}
  + 不允许为空：{{c1:: Not Null }}

### Default属性

+ 语法：`money decimal(16,2) default 0.00 not null`
+ 触发默认值
  * 自动触发：{{c1:: 数据插入时不给字段赋值 }}
  * 手动触发：{{c1:: 数据插入时主动使用default关键字 }}

### 主键

**主键**：{{c1:: `primary key`，用来保证整张表中对应的字段永远不会出现重复数据}}
* 唯一性：{{c1:: 主键在一张表中只能有一个 }}
* 索引：{{c1:: 主键的字段会自动创建索引 }}
* 主键不能为空：{{c1:: Not Null（默认） }}
* **逻辑主键**：{{c1:: 数据没有具体业务意义，纯粹是一种数值数据 }}
  * 逻辑主键通常是整数：{{c1:: int }}
  * 逻辑主键目的：{{c1:: 是方便检索和数据安全（不暴露数据真实信息）}}
* **复合主键**：{{c1:: 多个字段共同组成不能重复的数据 }}
  * 语法：{{c1:: `primary key(字段1,字段2,...字段N)` }}
  * 注意点：{{c1:: 联合主键使用不多，一般也不会超过2个字段 }}

### 主键管理

+ 删除主键语法：`alter table t_26 drop primary key;`
+ 后期新增主键语法：`alter table t_26 add primary key(account,name);`
  + 注意：如果是针对业务主键需要保证字段数据没有Null数据且没有数据重复

### 自增长属性
**自增长**：{{c1:: `auto_increment`}}
+ 语法：`id int primary key auto_increment`
+ 必要条件：{{c1:: 自增长只能是整数类型，而且对应的字段必须是一个索引（通常逻辑主键） }}
+ 唯一性：{{c1:: 一张表只能有一个自动增长类型 }}
+ 自增长的触发:{{c1:: 通过不给值（默认值）实现自动计算 }}
+ 自增长属性由两个变量控制
* 初始值：{{c1:: `auto_increment_offset`，默认是1 }}
* 步长：{{c1:: `auto_increment_increment`，默认值也是1 }}
* 查看自增长控制：{{c1:: `show variables like 'auto_increment%';` }}

### 自增长管理

+ 修改表中自增长的值，跳过一些值，直接从下次开始按照新的目标值出现
  ```sql
    #{{c1::
    alter table t_28 auto_increment = 50;
    #}}
  ```
+ 修改自增长控制：步长和起始值
  ```sql
    #{{c1::
    set auto_increment_increment = 2;	# 当前用户当前连接有效（局部）
    set @@auto_increment_increment = 2;	# 所有用户一直有效（全局）
    #}}
  ```

### 唯一键

**唯一键**：{{c1:: unique key，用来维护数据的唯一性 }}
+ 语法：{{c1:: `username varchar(50) unique, `}}
* 多个：{{c1:: 一个表中可以有多个唯一键 }}
* 唯一键与主键的区别:{{c1:: 在于唯一键允许数据为Null（而且Null的数量不限） }}
* 索引：{{c1:: 唯一键的字段会自动创建索引 }}
* 复合唯一键语法：{{c1:: `unique key(字段1,字段2,...字段N)` }}

### 唯一键管理

* 删除唯一键：一张表中不止一个唯一键，必须指定唯一键名字：{{c1:: `alter table 表名 drop index 唯一键名字；` }}
* 新增唯一键：{{c1:: `alter table 表名 add unique key(字段列表)；` }}

### 数据库记录长度

**数据库记录长度**：{{c1:: MySQL中规定一条记录所占用的存储长度最长不超过65535个**字节**}}
* 记录长度为：{{c1:: 表中所有字段预计占用的长度之和}}
* 所有字段只有允许Null存在：{{c1:: 系统就会预留一个字节存储Null（多个Null也只要一个就好）}}
* 因为MySQL记录长度的存在，varchar永远达不到理论长度
  * GBK存储：{{c1:: 65535（字符） * 2 + 2 = 131072（字节）}}
  * UTF8存储：{{c1:: 65535（字符） * 3 + 2 = 196607（字节）}}
* 一般数据长度超过255个字符都会{{c1:: 使用text/blob进行存储（数据存储不占用记录长度） }}

### 范式

##
+ **范式**：{{c1:: `Normal Format`，表示一个关系内部各属性之间的联系的合理化程度 }}
* 范式目标:{{c1:: 在满足组织和存储的前提下使数据结构冗余最小化  }}
* 目前数据库应用到的范式有以下几层
  * {{c1:: 第一范式：1NF }}
  * {{c1:: 第二范式：2NF }}
  * {{c1:: 第三范式：3NF }}
  * {{c1:: 逆规范化 }}

### 第一范式

  + **第一范式**：{{c1:: 1NF，数据字段设计时必须满足**原子性**}}
  + **原子性**:{{c1:: 要求字段数据是不需要拆分就可以直接应用}}
  + 目的：{{c1:: 1NF就是要字段数据颗粒度最小，保证数据取出来使用的时候不用再拆分}}

### 第二范式

+ **第二范式**：{{c1:: 2NF，字段设计不能存在部分依赖 }}
+ 部分依赖：{{c1:: 首先表存在复合主键，其次有的字段不是依赖整个主键，而只是依赖主键中的一部分 }}
+ 正确方式：{{c1:: 将部分依赖关系独立成表 }}

### 第三范式

+ **第三范式**：{{c1:: 3NF，字段设计不能存在传递依赖}}
* 传递依赖：{{c1:: 字段某个非主属性不直接依赖主属性，而是通过依赖某个其他非主属性而传递到主属性之上}}
* 传递依赖解决：{{c1:: 让依赖非主属性的字段与依赖字段独立成表}}

