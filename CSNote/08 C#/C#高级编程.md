### 11.4.3 使用LINQ 和不变的数组 
## 11.5 并发集合 
### 11.5.1 创建管道 
### 11.5.2 使用BlockingCollection 
### 11.5.3 使用ConcurrentDictionary 
### 11.5.4 完成管道 
## 11.6 小结 
# 第12章 LINQ 
## 12.4 表达式树 
## 12.5 LINQ 提供程序 
## 12.6 小结 
# 第13章 C#函数式编程 
## 13.1 概述 
### 13.1.1 避免状态突变 
### 13.1.2 函数作为第一个类 
## 13.2 表达式体的成员 
## 13.3 扩展方法 
## 13.4 using static 声明 
## 13.5 本地函数 
### 13.5.1 本地函数与yield 语句 
### 13.5.2 递归本地函数 
## 13.6 元组 
### 13.6.1 元组的声明和初始化 
### 13.6.2 元组解构 
### 13.6.3 元组的返回 
### 13.6.4 幕后的原理 
### 13.6.5 ValueTuple 与元组的兼容性 
### 13.6.6 推断出元组名称 
### 13.6.7 元组与链表 
### 13.6.8 元组和LINQ 
### 13.6.9 解构 
### 13.6.10 解构与扩展方法 
## 13.7 模式匹配 
### 13.7.1 模式匹配与is 运算符 
### 13.7.2 模式匹配与switch 语句 
### 13.7.3 模式匹配与泛型 
## 13.8 小结 
# 第14章 错误和异常 
## 14.1 简介 
## 14.2 异常类 
## 14.3 捕获异常 
### 14.3.1 异常和性能 
### 14.3.2 实现多个catch 块 
### 14.3.3 在其他代码中捕获异常 
### 14.3.4 System.Exception 属性 
### 14.3.5 异常过滤器 
### 14.3.6 重新抛出异常 
### 14.3.7 没有处理异常时发生的情况 
## 14.4 用户定义的异常类 
### 14.4.1 捕获用户定义的异常 
### 14.4.2 抛出用户定义的异常 
### 14.4.3 定义用户定义的异常类 
## 14.5 调用者信息 
## 14.6 小结 
# 第15章 异步编程 
## 15.1 异步编程的重要性 
## 15.2 异步编程的.NET 历史 
### 15.2.1 同步调用 
### 15.2.2 异步模式 
### 15.2.3 基于事件的异步模式 
### 15.2.4 基于任务的异步模式 
### 15.2.5 异步Main()方法 
## 15.3 异步编程的基础 
### 15.3.1 创建任务 
### 15.3.2 调用异步方法 
### 15.3.3 使用Awaiter 
### 15.3.4 延续任务 
### 15.3.5 同步上下文 
### 15.3.6 使用多个异步方法 
### 15.3.7 使用ValueTasks 
### 15.3.8 转换异步模式 
## 15.4 错误处理 
### 15.4.1 异步方法的异常处理 
### 15.4.2 多个异步方法的异常处理 
### 15.4.3 使用AggregateException 信息 
## 15.5 异步与Windows 应用程序 
### 15.5.1 配置await 
### 15.5.2 切换到UI 线程 
### 15.5.3 使用IAsyncOperation 
### 15.5.4 避免阻塞情况 
## 15.6 小结 
# 第16章 反射、元数据和动态编程 
## 16.1 在运行期间检查代码和动态编程 
## 16.2 自定义特性 
### 16.2.1 编写自定义特性 
### 16.2.2 自定义特性示例：WhatsNewAttributes 
## 16.3 反射 
### 16.3.1 System.Type 类 
### 16.3.2 TypeView 示例 
### 16.3.3 Assembly 类 
### 16.3.4 完成WhatsNewAttributes 示例 
## 16.4 为反射使用动态语言扩展 
### 16.4.1 创建Calculator 库 
### 16.4.2 动态实例化类型 
### 16.4.3 用Reflection API 调用成员 
### 16.4.4 使用动态类型调用成员 
## 16.5 dynamic 类型 
## 16.6 DynamicObject 和ExpandoObject概述 
### 16.6.1 DynamicObject 
### 16.6.2 ExpandoObject 
## 16.7 小结 
# 第17章 托管和非托管内存 
## 17.1 内存 
## 17.2 后台内存管理 
### 17.2.1 值数据类型 
### 17.2.2 引用数据类型 
### 17.2.3 垃圾收集 
## 17.3 强引用和弱引用 
## 17.4 处理非托管的资源 
### 17.4.1 析构函数或终结器 
### 17.4.2 IDisposable 接口 
### 17.4.3 using 语句 
### 17.4.4 实现IDisposable 接口和析构函数 
### 17.4.5 IDisposable 和终结器的规则 
## 17.5 不安全的代码 
### 17.5.1 用指针直接访问内存 
### 17.5.2 指针示例：PointerPlayground 
### 17.5.3 使用指针优化性能 
## 17.6 引用的语义 
### 17.6.1 传递ref 和返回ref 
### 17.6.2 ref 和数组 
## 17.7 Span<T> 
### 17.7.1 Span 引用托管堆 
### 17.7.2 Span 引用栈 
### 17.7.3 Span 引用本机堆 
### 17.7.4 Span 扩展方法 
## 17.8 平台调用 
## 17.9 小结 
# 第18章 Visual Studio 2017 
## 18.1 使用Visual Studio 2017 
### 18.1.1 Visual Studio 的版本 
### 18.1.2 Visual Studio 设置 
## 18.2 创建项目 
### 18.2.1 面向多个版本的.NET 
### 18.2.2 选择项目类型 
## 18.3 浏览并编写项目 
### 18.3.1 Solution Explorer 
### 18.3.2 使用代码编辑器 
### 18.3.3 学习和理解其他窗口 
### 18.3.4 排列窗口 
## 18.4 构建项目 
### 18.4.1 构建、编译和生成代码 
### 18.4.2 调试版本和发布版本 
### 18.4.3 选择配置 
### 18.4.4 编辑配置 
## 18.5 调试代码 
### 18.5.1 设置断点 
### 18.5.2 使用数据提示和调试器可视化工具 
### 18.5.3 Live Visual Tree 
### 18.5.4 监视和修改变量 
### 18.5.5 异常 
### 18.5.6 多线程 
## 18.6 重构工具 
## 18.7 诊断工具 
## 18.8 通过Docker 创建和使用容器 
### 18.8.1 Docker 简介 
### 18.8.2 在Docker 容器中运行ASP .NET Core 
### 18.8.3 创建Dockerfile 
### 18.8.4 使用Visual Studio 
## 18.9 小结 
# 第II 部分 .NET Core 与Windows Runtime
# 第19章 库、程序集、包和NuGet 
## 19.1 库的地狱 
## 19.2 程序集 
## 19.3 创建库 
### 19.3.1 .NET 标准 
### 19.3.2 创建.NET 标准库 
### 19.3.3 解决方案文件 
### 19.3.4 引用项目 
### 19.3.5 引用NuGet 包 
### 19.3.6 NuGet 的来源 
### 19.3.7 使用.NET Framework 库 
## 19.4 使用共享项目 
## 19.5 创建NuGet 包 
### 19.5.1 NuGet 包和命令行 
### 19.5.2 支持多个平台 
### 19.5.3 NuGet 包与Visual Studio 
## 19.6 小结 
# 第20章 依赖注入 
## 20.1 依赖注入的概念 
### 20.1.1 使用没有依赖注入的服务 
### 20.1.2 使用依赖注入 
## 20.2 使用.NET Core DI 容器 
## 20.3 服务的生命周期 
### 20.3.1 使用单例和临时服务 
### 20.3.2 使用Scoped 服务 
### 20.3.3 使用自定义工厂 
## 20.4 使用选项初始化服务 
## 20.5 使用配置文件 
## 20.6 创建平台独立性 
### 20.6.1 .NET 标准库 
### 20.6.2 WPF 应用程序 
### 20.6.3 UWP 应用程序 
### 20.6.4 Xamarin 应用程序 
## 20.7 使用其他DI 容器 
## 20.8 小结 
# 第21章 任务和并行编程 
## 21.1 概述 
## 21.2 Parallel 类 
### 21.2.1 使用Parallel.For()方法循环 
### 21.2.2 提前中断Parallel.For 
### 21.2.3 Parallel.For()方法的初始化 
### 21.2.4 使用Parallel.ForEach()方法循环 
### 21.2.5 通过Parallel.Invoke()方法调用多个方法 
## 21.3 任务 
### 21.3.1 启动任务 
### 21.3.2 Future——任务的结果 
### 21.3.3 连续的任务 
### 21.3.4 任务层次结构 
### 21.3.5 从方法中返回任务 
### 21.3.6 等待任务 
## 21.4 取消架构 
### 21.4.1 Parallel.For()方法的取消 
### 21.4.2 任务的取消 
## 21.5 数据流 
### 21.5.1 使用动作块 
### 21.5.2 源和目标数据块 
### 21.5.3 连接块 
## 21.6 Timer 类 
## 21.7 线程问题 
### 21.7.1 争用条件 
### 21.7.2 死锁 
## 21.8 lock 语句和线程安全 
## 21.9 Interlocked 类 
## 21.10 Monitor 类 
## 21.11 SpinLock 结构 
## 21.12 WaitHandle 基类 
## 21.13 Mutex 类 
## 21.14 Semaphore 类 
## 21.15 Events 类 
## 21.16 Barrier 类 
## 21.17 ReaderWriterLockSlim 类 
## 21.18 Lock 和await 
## 21.19 小结 
# 第22章 文件和流 
## 22.1 概述 
## 22.2 管理文件系统 
### 22.2.1 检查驱动器信息 
### 22.2.2 使用Path 类 
### 22.2.3 创建文件和文件夹 
### 22.2.4 访问和修改文件属性 
### 22.2.5 使用File 执行读写操作 
## 22.3 枚举文件 
## 22.4 使用流 
### 22.4.1 使用文件流 
### 22.4.2 读取流 
### 22.4.3 写入流 
### 22.4.4 复制流 
### 22.4.5 随机访问流 
### 22.4.6 使用缓存的流 
## 22.5 使用读取器和写入器 
### 22.5.1 StreamReader 类 
### 22.5.2 StreamWriter 类 
### 22.5.3 读写二进制文件 
## 22.6 压缩文件 
### 22.6.1 使用压缩流 
### 22.6.2 使用Brotli 
### 22.6.3 压缩文件 
## 22.7 观察文件的更改 
## 22.8 使用内存映射的文件 
### 22.8.1 使用访问器创建内存映射文件 
### 22.8.2 使用流创建内存映射文件 
## 22.9 使用管道通信 
### 22.9.1 创建命名管道服务器 
### 22.9.2 创建命名管道客户端 
### 22.9.3 创建匿名管道 
## 22.10 通过Windows 运行库使用文件和流 
### 22.10.1 Windows App 编辑器 
### 22.10.2 把Windows Runtime 类型映射为.NET 类型 
## 22.11 小结 
# 第23章 网络 
## 23.1 概述 
## 23.2 HttpClient 类 
### 23.2.1 发出异步的Get 请求 
### 23.2.2 抛出异常 
### 23.2.3 传递标题 
### 23.2.4 访问内容 
### 23.2.5 用HttpMessageHandler 自定义请求 
### 23.2.6 使用SendAsync 创建HttpRequestMessage 
### 23.2.7 使用HttpClient和Windows Runtime 
## 23.3 使用WebListener 类 
## 23.4 使用实用工具类 
### 23.4.1 URI 
### 23.4.2 IPAddress 
### 23.4.3 IPHostEntry 
### 23.4.4 Dns 
## 23.5 使用TCP 
### 23.5.1 使用TCP 创建HTTP 客户程序 
### 23.5.2 创建TCP 侦听器 
### 23.5.3 创建TCP 客户端 
### 23.5.4 TCP 和UDP 
## 23.6 使用UDP 
### 23.6.1 建立UDP 接收器 
### 23.6.2 创建UDP 发送器 
### 23.6.3 使用多播 
## 23.7 使用套接字 
### 23.7.1 使用套接字创建侦听器 
### 23.7.2 使用NetworkStream 和套接字 
### 23.7.3 通过套接字使用读取器和写入器 
### 23.7.4 使用套接字实现接收器 
## 23.8 小结 
# 第24章 安全性 
## 24.1 概述 
## 24.2 验证用户信息 
### 24.2.1 使用Windows 标识 
### 24.2.2 Windows Principal 
### 24.2.3 使用声称 
## 24.3 加密数据 
### 24.3.1 创建和验证签名 
### 24.3.2 实现安全的数据交换 
### 24.3.3 使用RSA 签名和散列 
## 24.4 保护数据 
### 24.4.1 实现数据保护 
### 24.4.2 用户机密 
## 24.5 资源的访问控制 
## 24.6 Web 安全性 
### 24.6.1 编码 
### 24.6.2 SQL 注入 
### 24.6.3 跨站点请求伪造 
## 24.7 小结 
# 第25章 ADO.NET 和事务 
## 25.1 ADO.NET 概述 
### 25.1.1 示例数据库 
### 25.1.2 NuGet 包和名称空间 
## 25.2 使用数据库连接 
### 25.2.1 管理连接字符串 
### 25.2.2 连接池 
### 25.2.3 连接信息 
## 25.3 命令 
### 25.3.1 ExecuteNonQuery()方法 
### 25.3.2 ExecuteScalar()方法 
### 25.3.3 ExecuteReader()方法 
### 25.3.4 调用存储过程 
## 25.4 异步数据访问 
## 25.5 事务 
## 25.6 事务和System.Transaction 
### 25.6.1 可提交的事务 
### 25.6.2 依赖事务 
### 25.6.3 环境事务 
### 25.6.4 嵌套作用域和环境事务 
## 25.7 小结 
# 第26章 Entity Framework Core 
## 26.1 Entity Framework 简史 
## 26.2 EF Core 简介 
### 26.2.1 创建模型 
### 26.2.2 约定、注释和流利API 
### 26.2.3 创建上下文 
### 26.2.4 创建数据库 
### 26.2.5 删除数据库 
### 26.2.6 写入数据库 
### 26.2.7 读取数据库 
### 26.2.8 更新记录 
### 26.2.9 删除记录 
### 26.2.10 日志记录 
## 26.3 使用依赖注入 
## 26.4 创建模型 
### 26.4.1 创建关系 
### 26.4.2 数据注释 
### 26.4.3 流利API 
### 26.4.4 自包含类型的配置 
### 26.4.5 在数据库中搭建模型 
### 26.4.6 映射到字段 
### 26.4.7 阴影属性 
## 26.5 查询 
### 26.5.1 基本查询 
### 26.5.2 客户端和服务器求值 
### 26.5.3 原始SQL 查询 
### 26.5.4 已编译查询 
### 26.5.5 全局查询过滤器 
### 26.5.6 EF.Functions 
## 26.6 关系 
### 26.6.1 使用约定的关系 
### 26.6.2 显式加载相关数据 
### 26.6.3 即时加载相关数据 
### 26.6.4 使用注释的关系 
### 26.6.5 使用流利API 的关系 
### 26.6.6 根据约定的每个层次结构的表 
### 26.6.7 使用流利API 的每个层次结构中的表 
### 26.6.8 表的拆分 
### 26.6.9 拥有的实体 
## 26.7 保存数据 
### 26.7.1 用关系添加对象 
### 26.7.2 对象的跟踪 
### 26.7.3 更新对象 
### 26.7.4 更新未跟踪的对象 
### 26.7.5 批处理 
## 26.8 冲突的处理 
### 26.8.1 最后一个更改获胜 
### 26.8.2 第一个更改获胜 
## 26.9 上下文池 
## 26.10 使用事务 
### 26.10.1 使用隐式的事务 
### 26.10.2 创建显式的事务 
## 26.11 迁移 
### 26.11.1 准备项目文件 
### 26.11.2 利用ASP.NET Core MVC 托管应用程序 
### 26.11.3 托管.NET Core 控制台应用程序 
### 26.11.4 创建迁移 
### 26.11.5 以编程方式应用迁移 
### 26.11.6 应用迁移的其他方法 
## 26.12 小结 
# 第27章 本地化 
## 27.1 全球市场 
## 27.2 System.Globalization 名称空间 
### 27.2.1 Unicode 问题 
### 27.2.2 区域性和区域 
### 27.2.3 使用区域性 
### 27.2.4 排序 
## 27.3 资源 
### 27.3.1 资源读取器和写入器 
### 27.3.2 使用资源文件生成器 
### 27.3.3 通过ResourceManager 使用资源文件 
### 27.3.4 System.Resources 名称空间 
## 27.4 使用ASP.NET Core 本地化 
### 27.4.1 注册本地化服务 
### 27.4.2 注入本地化服务 
### 27.4.3 区域性提供程序 
### 27.4.4 在ASP.NET Core 中使用资源 
### 27.4.5 使用控制器和视图进行本地化 
## 27.5 本地化UWP 
### 27.5.1 给UWP 使用资源 
### 27.5.2 使用多语言应用程序工具集进行本地化 
## 27.6 小结 
# 第28章 测试 
## 28.1 概述 
## 28.2 使用MSTest 进行单元测试 
### 28.2.1 使用MSTest 创建单元测试 
### 28.2.2 运行单元测试 
### 28.2.3 使用MSTest 预期异常 
### 28.2.4 测试全部代码路径 
### 28.2.5 外部依赖 
## 28.3 使用xUnit 进行单元测试 
### 28.3.1 使用xUnit 和.NET Core 
### 28.3.2 创建Fact 属性 
### 28.3.3 创建Theory 特性 
### 28.3.4 使用Mocking 库 
## 28.4 实时单元测试 
## 28.5 使用EF Core 进行单元测试 
## 28.6 使用Windows 应用程序进行UI测试 
## 28.7 Web 集成、负载和性能测试 
### 28.7.1 ASP.NET Core 集成测试 
### 28.7.2 创建Web 测试 
### 28.7.3 运行Web 测试 
## 28.8 小结 
# 第29章 跟踪、日志和分析 
## 29.1 诊断概述 
## 29.2 使用EventSource 跟踪 
### 29.2.1 EventSource 的简单用法 
### 29.2.2 跟踪工具 
### 29.2.3 派生自EventSource 
### 29.2.4 使用注释和EventSource 
### 29.2.5 创建事件清单模式 
### 29.2.6 使用活动ID 
## 29.3 创建自定义侦听器 
## 29.4 使用ILogger 接口编写日志 
### 29.4.1 配置提供程序 
### 29.4.2 使用作用域 
### 29.4.3 过滤 
### 29.4.4 配置日志记录 
### 29.4.5 使用没有依赖注入的ILogger 
## 29.5 使用Visual Studio App Center进行分析 
## 29.6 小结 
# 第III 部分 Web 应用程序和服务
# 第30章 ASP.NET Core 
## 30.1 概述 
## 30.2 Web 技术 
### 30.2.1 HTML 
### 30.2.2 CSS 
### 30.2.3 JavaScript 和TypeScript 
### 30.2.4 脚本库 
## 30.3 ASP.NET Web 项目 
### 30.3.1 启动 
### 30.3.2 示例应用程序 
## 30.4 添加客户端内容 
### 30.4.1 为客户端内容使用工具 
### 30.4.2 通过Bower 使用客户端库 
### 30.4.3 使用JavaScript 包管理器npm 
### 30.4.4 捆绑 
### 30.4.5 用webpack 打包 
## 30.5 请求和响应 
### 30.5.1 请求标题 
### 30.5.2 查询字符串 
### 30.5.3 编码 
### 30.5.4 表单数据 
### 30.5.5 cookie 
### 30.5.6 发送JSON 
## 30.6 依赖注入 
### 30.6.1 定义服务 
### 30.6.2 注册服务 
### 30.6.3 注入服务 
### 30.6.4 调用控制器 
## 30.7 简单的路由 
## 30.8 创建自定义的中间件 
## 30.9 会话状态 
## 30.10 用ASP.NET Core 配置 
### 30.10.1 读取配置 
### 30.10.2 修改配置提供程序 
### 30.10.3 基于环境的不同配置 
## 30.11 小结 
# 第31章 ASP.NET Core MVC 
## 31.1 为ASP.NET Core MVC 建立服务 
## 31.2 定义路由 
### 31.2.1 添加路由 
### 31.2.2 使用路由约束 
## 31.3 创建控制器 
### 31.3.1 理解动作方法 
### 31.3.2 使用参数 
### 31.3.3 返回数据 
### 31.3.4 使用Controller 基类和POCO控制器 
## 31.4 创建视图 
### 31.4.1 向视图传递数据 
### 31.4.2 Razor 语法 
### 31.4.3 创建强类型视图 
### 31.4.4 定义布局 
### 31.4.5 用部分视图定义内容 
### 31.4.6 使用视图组件 
### 31.4.7 在视图中使用依赖注入 
### 31.4.8 为多个视图导入名称空间 
## 31.5 从客户端提交数据 
### 31.5.1 模型绑定器 
### 31.5.2 注解和验证 
## 31.6 使用HTML Helper 
### 31.6.1 简单的Helper 
### 31.6.2 使用模型数据 
### 31.6.3 定义HTML 特性 
### 31.6.4 创建列表 
### 31.6.5 强类型化的Helper 
### 31.6.6 编辑器扩展 
### 31.6.7 实现模板 
## 31.7 Tag Helper 
### 31.7.1 激活Tag Helper 
### 31.7.2 使用锚定Tag Helper 
### 31.7.3 使用Label Tag Helper 
### 31.7.4 使用Input Tag Helper 
### 31.7.5 使用表单进行验证 
### 31.7.6 environment Tag Helper 
### 31.7.7 创建自定义Tag Helper 
### 31.7.8 用Tag Helper 创建元素 
## 31.8 实现动作过滤器 
## 31.9 创建数据驱动的应用程序 
### 31.9.1 定义模型 
### 31.9.2 创建数据库 
### 31.9.3 创建服务 
### 31.9.4 创建控制器 
### 31.9.5 创建视图 
## 31.10 实现身份验证和授权 
### 31.10.1 存储和检索用户信息 
### 31.10.2 启动身份系统 
### 31.10.3 执行用户注册 
### 31.10.4 设置用户登录 
### 31.10.5 验证用户的身份 
### 31.10.6 使用Azure Active Directory 对用户进行身份验证 
## 31.11 Razor 页面 
### 31.11.1 创建一个Razor 页面项目 
### 31.11.2 实现数据访问 
### 31.11.3 使用内联代码 
### 31.11.4 使用内联代码和页面模型 
### 31.11.5 使用代码隐藏文件 
### 31.11.6 页面参数 
## 31.12 小结 
# 第32章 Web API 
## 32.1 概述 
## 32.2 创建服务 
### 32.2.1 定义模型 
### 32.2.2 创建服务 
### 32.2.3 创建控制器 
### 32.2.4 修改响应格式 
### 32.2.5 REST 结果和状态码 
## 32.3 创建异步服务 
## 32.4 创建.NET 客户端 
### 32.4.1 发送GET 请求 
### 32.4.2 从服务中接收XML 
### 32.4.3 发送POST 请求 
### 32.4.4 发送PUT 请求 
### 32.4.5 发送DELETE 请求 
## 32.5 写入数据库 
### 32.5.1 使用EF Core 
### 32.5.2 创建数据访问服务 
## 32.6 用OpenAPI 或Swagger 创建元数据 
## 32.7 创建和使用OData服务 
### 32.7.1 创建数据模型 
### 32.7.2 创建数据库 
### 32.7.3 OData 启动代码 
### 32.7.4 创建OData 控制器 
### 32.7.5 OData 查询 
## 32.8 使用Azure Function 
### 32.8.1 创建Azure Function 
### 32.8.2 使用依赖注入容器 
### 32.8.3 实现GET、POST 和PUT 请求 
### 32.8.4 运行Azure Function 
## 32.9 小结 
# 第IV 部分 应用程序
# 第33章 Windows 应用程序 
## 33.1 Windows 应用程序简介 
### 33.1.1 Windows 运行库 
### 33.1.2 Hello, Windows 
### 33.1.3 应用程序清单文件 
### 33.1.4 应用程序启动 
### 33.1.5 主页 
## 33.2 XAML 
### 33.2.1 XAML 标准 
### 33.2.2 将元素映射到类 
### 33.2.3 通过XAML 使用定制的.NET 类 
### 33.2.4 将属性用作特性 
### 33.2.5 将属性用作元素 
### 33.2.6 依赖属性 
### 33.2.7 创建依赖属性 
### 33.2.8 值变更回调和事件 
### 33.2.9 路由事件 
### 33.2.10 附加属性 
### 33.2.11 标记扩展 
### 33.2.12 自定义标记扩展 
### 33.2.13 条件XAML 
## 33.3 控件 
### 33.3.1 框架派生的UI 元素 
### 33.3.2 控件派生的控件 
### 33.3.3 范围控件 
### 33.3.4 内容控件 
### 33.3.5 按钮 
### 33.3.6 项控件 
### 33.3.7 Flyout 控件 
## 33.4 数据绑定 
### 33.4.1 用INotifyPropertyChanged 更改通知 
### 33.4.2 创建图书列表 
### 33.4.3 列表绑定 
### 33.4.4 把事件绑定到方法 
### 33.4.5 使用数据模板和数据模板选择器 
### 33.4.6 绑定简单对象 
### 33.4.7 值的转换 
## 33.5 导航 
### 33.5.1 导航回最初的页面 
### 33.5.2 重写Page 类的导航 
### 33.5.3 在页面之间导航 
### 33.5.4 后退按钮 
### 33.5.5 Hub 
### 33.5.6 Pivot 
### 33.5.7 NavigationView 
## 33.6 布局 
### 33.6.1 StackPanel 
### 33.6.2 Canvas 
### 33.6.3 Grid 
### 33.6.4 VariableSizedWrapGrid 
### 33.6.5 RelativePanel 
### 33.6.6 自适应触发器 
### 33.6.7 XAML 视图 
### 33.6.8 延迟加载 
## 33.7 小结 
# 第34章 模式和XAML 应用程序 
## 34.1 使用 MVVM 的原因 
## 34.2 定义 MVVM 模式 
## 34.3 共享代码 
### 34.3.1 使用API 协定和通用Windows平台 
### 34.3.2 使用共享项目 
### 34.3.3 使用.NET 标准库 
## 34.4 示例解决方案 
## 34.5 模型 
### 34.5.1 实现变更通知 
### 34.5.2 使用Repository 模式 
## 34.6 服务 
## 34.7 视图模型 
### 34.7.1 使用IEditableObject 
### 34.7.2 视图模型的具体实现 
### 34.7.3 命令 
### 34.7.4 服务、ViewModel 和依赖注入 
## 34.8 视图 
### 34.8.1 从视图模型中打开对话框 
### 34.8.2 页面之间的导航 
### 34.8.3 自适应用户界面 
### 34.8.4 显示进度信息 
### 34.8.5 使用列表项中的操作 
## 34.9 使用事件传递消息 
## 34.10 使用框架 
## 34.11 小结 
# 第35章 样式化Windows 应用程序 
## 35.1 样式设置 
## 35.2 形状 
## 35.3 几何图形 
### 35.3.1 使用段的几何图形 
### 35.3.2 使用PathMarkup 的几何图形 
## 35.4 变换 
### 35.4.1 缩放 
### 35.4.2 平移 
### 35.4.3 旋转 
### 35.4.4 倾斜 
### 35.4.5 组合变换和复合变换 
### 35.4.6 使用矩阵的变换 
## 35.5 画笔 
### 35.5.1 SolidColorBrush 
### 35.5.2 LinearGradientBrush 
### 35.5.3 ImageBrush 
### 35.5.4 AcrylicBrush 
### 35.5.5 RevealBrush 
## 35.6 样式和资源 
### 35.6.1 样式 
### 35.6.2 资源 
### 35.6.3 从代码中访问资源 
### 35.6.4 资源字典 
### 35.6.5 主题资源 
## 35.7 模板 
### 35.7.1 控件模板 
### 35.7.2 数据模板 
### 35.7.3 样式化ListView 
### 35.7.4 ListView 项的数据模板 
### 35.7.5 项容器的样式 
### 35.7.6 项面板 
### 35.7.7 列表视图的控件模板 
## 35.8 动画 
### 35.8.1 时间轴 
### 35.8.2 缓动函数 
### 35.8.3 关键帧动画 
### 35.8.4 过渡 
## 35.9 可视化状态管理器 
### 35.9.1 用控件模板预定义状态 
### 35.9.2 定义自定义状态 
### 35.9.3 设置自定义的状态 
## 35.10 小结 
# 第36章 高级Windows 应用程序 
## 36.1 概述 
## 36.2 应用程序的生命周期 
### 36.2.1 应用程序的执行状态 
### 36.2.2 在页面之间导航 
## 36.3 导航状态 
### 36.3.1 暂停应用程序 
### 36.3.2 激活暂停的应用程序 
### 36.3.3 测试暂停 
### 36.3.4 页面状态 
## 36.4 共享数据 
### 36.4.1 共享源 
### 36.4.2 共享目标 
## 36.5 应用程序服务 
### 36.5.1 创建模型 
### 36.5.2 为应用程序服务连接创建后台任务 
### 36.5.3 注册应用程序服务 
### 36.5.4 调用应用程序服务 
## 36.6 高级的编译绑定 
### 36.6.1 已编译数据绑定的生命周期 
### 36.6.2 绑定到方法上 
### 36.6.3 用x:Bind 分阶段 
## 36.7 使用文本 1
### 36.7.1 使用字体 1
### 36.7.2 内联和块元素 1
### 36.7.3 使用溢出区域 1
## 36.8 上墨 1
## 36.9 自动建议 1
## 36.10 小结 1
# 第37章 Xamarin.Forms 1
## 37.1 Xamarin 开发入门 1
### 37.1.1 用Android 架构Xamarin 1
### 37.1.2 用iOS 架构Xamarin 1
### 37.1.3 Xamarin.Forms 1
## 37.2 Xamarin 开发工具 1
### 37.2.1 Android 1
### 37.2.2 iOS 1
### 37.2.3 Visual Studio 2017 1
### 37.2.4 Visual Studio for Mac 1
### 37.2.5 Visual Studio App Center 1
## 37.3 Android 基础 1
### 37.3.1 活动 1
### 37.3.2 资源 1
### 37.3.3 显示列表 1
### 37.3.4 显示消息 1
## 37.4 iOS 基础 1
### 37.4.1 iOS 应用程序结构 1
### 37.4.2 故事板 1
### 37.4.3 控制器 1
### 37.4.4 显示消息 1
## 37.5 Xamarin. Forms 应用程序 1
### 37.5.1 托管Xamarin 的Windows应用程序 1
### 37.5.2 托管Xamarin 的Android 1
### 37.5.3 托管Xamarin 的iOS 1
### 37.5.4 共享的项目 1
## 37.6 使用公共库 1
## 37.7 控件层次结构 1
## 37.8 页面 1
## 37.9 导航 1
## 37.10 布局 1
## 37.11 视图 1
## 37.12 数据绑定 1
## 37.13 命令 1
## 37.14 ListView 和ViewCell 1
## 37.15 小结 1
#附赠章节电子版(请扫描封底二维码获取)
# 第1章 Composition 
BC1.1 概述 
BC1.2 Composition 库的体系结构 
### BC1.2.1 使用特性的Composition 
### BC1.2.2 基于约定的部件注册 
BC1.3 定义协定 
BC1.4 导出部件 
### BC1.4.1 创建部件 
### BC1.4.2 使用部件的部件 
### BC1.4.3 导出元数据 
### BC1.4.4 使用元数据进行惰性加载 
BC1.5 导入部件 
### BC1.5.1 导入连接 
### BC1.5.2 部件的惰性加载 
### BC1.5.3 读取元数据 
BC1.6 小结 
# 第2章 XML 和JSON 
BC2.1 数据格式 
### BC2.1.1 XML 
### BC2.1.2 .NET 支持的XML 标准 
### BC2.1.3 在框架中使用XML 
### BC2.1.4 JSON 
BC2.2 读写流格式的XML 
### BC2.2.1 使用XmlReader 类读取XML 
### BC2.2.2 使用XmlWriter 类 
BC2.3 在.NET 中使用DOM 
### BC2.3.1 使用XmlDocument 类读取 
### BC2.3.2 遍历层次结构 
### BC2.3.3 使用XmlDocument 插入节点 
BC2.4 使用XPathNavigator 类 
### BC2.4.1 XPathDocument 类 
### BC2.4.2 XPathNavigator 类 
### BC2.4.3 XPathNodeIterator 类 
### BC2.4.4 使用XPath 导航XML 
### BC2.4.5 使用XPath 评估 
### BC2.4.6 用XPath 修改XML 
BC2.5 在XML 中序列化对象 
### BC2.5.1 序列化简单对象 
### BC2.5.2 序列化一个对象树 
### BC2.5.3 没有特性的序列化 
BC2.6 LINQ to XML 
### BC2.6.1 XDocument 对象 
### BC2.6.2 XElement 对象 
### BC2.6.3 XNamespace 对象 
### BC2.6.4 XComment 对象 
### BC2.6.5 XAttribute 对象 
### BC2.6.6 使用LINQ 查询XML 文档 
### BC2.6.7 查询动态的XML 文档 
### BC2.6.8 转换为对象 
### BC2.6.9 转换为XML 
BC2.7 JSON 
### BC2.7.1 创建JSON 
### BC2.7.2 转换对象 
### BC2.7.3 序列化对象 
### BC2.7.4 遍历JSON 节点 
BC2.8 小结 
# 第3章 WebHooks 和SignalR 
BC3.1 概述 
BC3.2 WebSockets 
### BC3.2.1 WebSockets 服务器 
### BC3.2.2 WebSockets 客户端 
BC3.3 使用SignalR 的简单聊天程序 
### BC3.3.1 创建集线器 
### BC3.3.2 用HTML 和JavaScript 创建客户端 
### BC3.3.3 创建SignalR .NET 客户端 
BC3.4 分组连接 
### BC3.4.1 用分组扩展集线器 
### BC3.4.2 用分组扩展Windows 客户端 
BC3.5 WebHooks 的体系结构 
BC3.6 创建Dropbox 和GitHub 接收器 
### BC3.6.1 创建Web 应用程序 
### BC3.6.2 为Dropbox 和GitHub 配置WebHooks 
### BC3.6.3 实现处理程序 
### BC3.6.4 用Dropbox 和GitHub 配置应用程序 
### BC3.6.5 运行应用程序 
BC3.7 小结 
# 第4章 机器人和认知服务 
BC4.1 机器人的定义 
BC4.2 创建对话框机器人 
### BC4.2.1 配置状态服务 
### BC4.2.2 接收机器人消息 .
### BC4.2.3 定义对话框 
### BC4.2.4 使用PromptDialog 
BC4.3 为对话框使用Form Flow 
BC4.4 创建英雄卡 
BC4.5 机器人和LUIS 
### BC4.5.1 定义意图和话语 
### BC4.5.2 访问LUIS 中的建议 
### BC4.5.3 使用带有活动检查的Form Flow 
BC4.6 小结 
# 第5章 Windows 应用程序的更多特性 
BC5.1 概述 
BC5.2 相机 
BC5.3 Geolocation 和MapControl 
### BC5.3.1 使用MapControl 
### BC5.3.2 使用Geolocator 定位信息 
### BC5.3.3 街景地图 
### BC5.3.4 继续请求位置信息 
BC5.4 传感器 
### BC5.4.1 光线 
### BC5.4.2 罗盘 
### BC5.4.3 加速计 
### BC5.4.4 倾斜计 
### BC5.4.5 陀螺仪 
### BC5.4.6 方向 
### BC5.4.7 Rolling Marble 示例 
BC5.5 小结 